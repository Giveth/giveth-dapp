const Web3 = require('web3');
const { LiquidPledging, LPVault, LPFactory, test } = require('giveth-liquidpledging');
const lpContracts = require('giveth-liquidpledging/build/contracts');
const { MiniMeToken, MiniMeTokenFactory } = require('minimetoken');
const contracts = require('./build/contracts/contracts');
const { StandardTokenTest } = test;
// const { LPPDacs, LPPDacsRuntimeByteCode } = require('lpp-dacs');
// const { LPPCampaignFactory, LPPCampaignRuntimeByteCode } = require('lpp-campaign');
// const { LPPCappedMilestones, LPPCappedMilestonesRuntimeByteCode } = require('lpp-capped-milestone');

const homeWeb3 = new Web3('https://ropsten.infura.io');
const foreignWeb3 = new Web3('https://rinkeby.infura.io');

// Ropsten network account only. DO NOT SEND ETH ON MAINNET!!!!
const ropstenPK = '0x36cad8c942c37943ead39f406cf0727abcd4b93f990560adfd54c81ed5544d69';
// Rinkeby network account only. DO NOT SEND ETH ON MAINNET!!!!
const rinkebyPK = '0xe47c8e639c3cfbba5044b7175da07f1302a8a89f85f8dbbf2263b1c0a52f290b';
const bridgePK = '0x54f5687fab46e0325a04ab6f703146ca657ddd1237cd5450e322913991c7d275';
const homeAccount = homeWeb3.eth.accounts.privateKeyToAccount(ropstenPK);
const foreignAccount = foreignWeb3.eth.accounts.privateKeyToAccount(rinkebyPK);
const bridgeAccount = foreignWeb3.eth.accounts.privateKeyToAccount(bridgePK);
homeWeb3.eth.accounts.wallet.add(homeAccount);
foreignWeb3.eth.accounts.wallet.add(foreignAccount);
foreignWeb3.eth.accounts.wallet.add(bridgeAccount);

const gasPrice = homeWeb3.utils.toWei('5.5', 'gwei');

async function deploy() {
    const bridgeAddy = bridgeAccount.address;

    const homeBridgeOwner = homeAccount.address;
    const securityGuard = homeAccount.address;

    let fiveDays = 60 * 60 * 24 * 5;
    let homeBridge;
    let homeToken;
    const homeBridgePromise = contracts.GivethBridge.new(
        homeWeb3,
        homeBridgeOwner,
        homeBridgeOwner,
        0,
        0,
        securityGuard,
        fiveDays,
        { from: homeBridgeOwner, $extraGas: 100000, gasPrice },
    )
        .on('transactionHash', txHash => console.log('givethBridge tx =>', txHash))
        .then(bridge => {
            homeBridge = bridge;
            return bridge.authorizeSpender(bridgeAddy, true, { from: homeBridgeOwner, gasPrice });
        })
        .then(() => {
            return StandardTokenTest.new(homeWeb3, { from: homeBridgeOwner, gasPrice }).on(
                'transactionHash',
                txHash => console.log('homeToken tx =>', txHash),
            );
        })
        .then(t => (homeToken = t));

    const foreignFrom = foreignAccount.address;

    let nonce = await foreignWeb3.eth.getTransactionCount(foreignFrom);

    let baseVault;
    LPVault.new(foreignWeb3, foreignFrom, {
        from: foreignFrom,
        gasPrice,
        nonce,
    })
        .on('transactionHash', txHash => console.log('LPVault tx ->', txHash))
        .then(c => (baseVault = c));
    nonce += 1;
    const baseLP = await LiquidPledging.new(foreignWeb3, foreignFrom, {
        from: foreignFrom,
        gasPrice,
        nonce,
    });
    const lpFactory = await LPFactory.new(foreignWeb3, baseVault.$address, baseLP.$address, {
        from: foreignFrom,
        gasPrice,
    }).on('transactionHash', txHash => console.log('lpFactory tx =>', txHash));

    const r = await lpFactory
        .newLP(foreignFrom, foreignFrom, { from: foreignFrom, gasPrice, $extraGas: 100000 })
        .on('transactionHash', txHash => console.log('lpFactory.newLP tx =>', txHash));

    const vaultAddress = r.events.DeployVault.returnValues.vault;
    const vault = new LPVault(foreignWeb3, vaultAddress);

    const lpAddress = r.events.DeployLiquidPledging.returnValues.liquidPledging;
    const liquidPledging = new LiquidPledging(foreignWeb3, lpAddress);

    nonce = await foreignWeb3.eth.getTransactionCount(foreignFrom);

    const tokenFactoryPromise = MiniMeTokenFactory.new(foreignWeb3, {
        from: foreignFrom,
        $extraGas: 100000,
        gasPrice,
        nonce,
    }).on('transactionHash', txHash => console.log('TokenFactory tx =>', txHash));
    nonce += 1;

    const kernel = new lpContracts.Kernel(foreignWeb3, await liquidPledging.kernel());
    const acl = new lpContracts.ACL(foreignWeb3, await kernel.acl());
    acl
        .createPermission(
            foreignFrom,
            vault.$address,
            await vault.CONFIRM_PAYMENT_ROLE(),
            foreignFrom,
            { from: foreignFrom, gasPrice, $extraGas: 100000, nonce },
        )
        .on('transactionHash', txHash => console.log('createPermission 1 tx =>', txHash));
    nonce += 1;
    await acl
        .createPermission(
            foreignFrom,
            vault.$address,
            await vault.SET_AUTOPAY_ROLE(),
            foreignFrom,
            {
                $extraGas: 100000,
                from: foreignFrom,
                gasPrice,
                nonce,
            },
        )
        .on('transactionHash', txHash => console.log('createPermission 2 tx =>', txHash));
    nonce += 1;

    const tokenFactory = await tokenFactoryPromise;

    vault
        .setAutopay(true, { from: foreignFrom, $extraGas: 100000, gasPrice, nonce })
        .on('transactionHash', txHash => console.log('setAutopay tx =>', txHash));
    nonce += 1;

    const foreignBridge = await contracts.ForeignGivethBridge.new(
        foreignWeb3,
        foreignFrom,
        foreignFrom,
        tokenFactory.$address,
        liquidPledging.$address,
        { from: bridgeAddy, $extraGas: 100000, gasPrice },
    ).on('transactionHash', txHash => console.log('foreignBridge tx =>', txHash));

    await foreignBridge
        .addToken(0, 'Ropsten ETH', 18, 'ROP_ETH', { from: bridgeAddy, gasPrice })
        .on('transactionHash', txHash => console.log('foreignBridge.addToken tx =>', txHash));
    const foreignEthAddress = await foreignBridge.tokenMapping(0);

    console.log({
        homeBridge: homeBridge.$address,
        homeToken: homeToken.$address,
        foreignBridge: foreignBridge.$address,
        lpFactory: lpFactory.$address,
        liquidPledging: liquidPledging.$address,
        foreignEth: foreignEthAddress,
    });
    process.exit(); // some reason, this script won't exit. I think it has to do with web3 subscribing to tx confirmations?
}

process.on('unhandledRejection', (reason, p) =>
    console.error('Unhandled Rejection at: Promise ', p, reason),
);

deploy();
