'use strict';

var _Observable = require('rxjs/Observable');

var _utils = require('./utils');

module.exports = function (settings, method) {
  return function () {
    var _this = this;

    var position = (0, _utils.getParamsPosition)(method);
    var params = arguments[position] || {};

    var cachedObservable = method === 'get' ? (0, _utils.getCachedObservable)(this._cache, 'get', /* id */arguments[0]) : undefined;

    // check if cached Observable exists
    if (cachedObservable) {
      return cachedObservable;
    }

    // create new Observable resource
    var options = (0, _utils.getOptions)(settings, this._rx, params.rx);
    var source = (0, _utils.getSource)(this[method].bind(this), arguments);
    var stream = source.concat(source.exhaustMap(function (data) {
      // Filter only data with the same id
      var filter = function filter(current) {
        return current[options.idField] === data[options.idField];
      };
      // `removed` events get special treatment
      var filteredRemoves = _this.removed$.filter(filter);
      // `created`, `updated` and `patched`
      var filteredEvents = _Observable.Observable.merge(_this.created$, _this.updated$, _this.patched$).filter(filter);

      return _Observable.Observable.merge(
      // Map to a callback that merges old and new data
      filteredEvents,
      // filtered `removed` events always mapped to `null`
      filteredRemoves.mapTo(null));
    }));

    // apply `let` function if set
    var letStream = options.let ? stream.let(options.let) : stream;

    // if the method is `get` cache the result, otherwise just return the stream
    return method === 'get' ? (0, _utils.cacheObservable)(this._cache, 'get', /* id */arguments[0], letStream) : letStream;
  };
};