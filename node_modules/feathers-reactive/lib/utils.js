'use strict';

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _utils = require('feathers-commons/lib/utils');

var _Observable = require('rxjs/Observable');

var _jsonStableStringify = require('json-stable-stringify');

var _jsonStableStringify2 = _interopRequireDefault(_jsonStableStringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var debug = (0, _debug3.default)('feathers-reactive');

function getSource(originalMethod, args) {
  var resultPromise = null;

  return _Observable.Observable.create(function (observer) {
    if (!resultPromise) {
      resultPromise = originalMethod.apply(undefined, _toConsumableArray(args));
      _assertPromise(resultPromise);
    }

    resultPromise.then(function (res) {
      observer.next(res);
      observer.complete();
    }).catch(function (e) {
      return observer.error(e);
    });
  });
}

function makeSorter(query, options) {
  // The sort function (if $sort is set)
  var sorter = query.$sort ? (0, _utils.sorter)(query.$sort) : (0, _utils.sorter)(_defineProperty({}, options.idField, 1));

  return function (result) {
    var isPaginated = !!result[options.dataField];
    var data = isPaginated ? result[options.dataField] : result;

    if (sorter) {
      data = data.sort(sorter);
    }

    var limit = typeof result.limit === 'number' ? result.limit : parseInt(query.$limit, 10);

    if (limit && !isNaN(limit)) {
      data = data.slice(0, limit);
    }

    if (isPaginated) {
      result[options.dataField] = data;
    } else {
      result = data;
    }

    return result;
  };
}

function getOptions(base) {
  for (var _len = arguments.length, others = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }

  var options = Object.assign.apply(Object, [{}, base].concat(others));

  if (typeof options.listStrategy === 'string') {
    options.listStrategy = options.listStrategies[options.listStrategy];
  }

  return options;
}

function cacheObservable(cache, method, key, observable) {
  var hash = _hash(key);

  var cachedObservable = observable.finally(function () {
    // clean cache on unsubscription (of all observers)
    debug('removing cache item: ', hash);
    delete cache[method][hash];
  }).shareReplay(1);

  cache[method][hash] = cachedObservable;

  return cache[method][hash];
}

function getCachedObservable(cache, method, key) {
  var hash = _hash(key);

  return cache[method][hash];
}

function getParamsPosition(method) {
  // The position of the params parameters for a service method so that we can extend them
  // default is 1

  var paramsPositions = {
    find: 0,
    update: 2,
    patch: 2
  };

  return method in paramsPositions ? paramsPositions[method] : 1;
}

function _assertPromise(obj) {
  if (!obj || typeof obj.then !== 'function' || typeof obj.catch !== 'function') {
    throw new Error('feathers-reactive only works with services that return a Promise');
  }
}

function _hash(key) {
  return (0, _jsonStableStringify2.default)(key);
}

Object.assign(exports, {
  getSource: getSource,
  makeSorter: makeSorter,
  getOptions: getOptions,
  cacheObservable: cacheObservable,
  getCachedObservable: getCachedObservable,
  getParamsPosition: getParamsPosition
});