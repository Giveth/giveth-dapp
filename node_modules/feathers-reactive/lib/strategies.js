'use strict';

var _Observable = require('rxjs/Observable');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

module.exports = function () {
  return {
    never: function never(source) {
      return source;
    },
    always: function always(source, options, args) {
      var _this = this;

      var params = args[0] || {};
      var query = Object.assign({}, params.query);
      var originalMethod = this.find.bind(this);

      // A function that returns if an item matches the query
      var matches = options.matcher(query);
      // A function that sorts a limits a result (paginated or not)
      var sortAndTrim = options.sorter(query, options);

      return source.concat(source.exhaustMap(function () {
        return _Observable.Observable.merge(_this.created$.filter(matches), _this.removed$, _this.updated$, _this.patched$).flatMap(function () {
          var source = _Observable.Observable.fromPromise(originalMethod.apply(undefined, _toConsumableArray(args)));

          return source.map(sortAndTrim);
        });
      }));
    },
    smart: function smart(source, options, args) {
      var _this2 = this;

      var params = args[0] || {};
      var query = Object.assign({}, params.query);
      // A function that returns if an item matches the query
      var matches = options.matcher(query);
      // A function that sorts a limits a result (paginated or not)
      var sortAndTrim = options.sorter(query, options);
      var onCreated = function onCreated(eventData) {
        return function (page) {
          var isPaginated = !!page[options.dataField];
          var process = function process(data) {
            return data.concat(eventData);
          };

          if (isPaginated) {
            return Object.assign({}, page, _defineProperty({
              total: page.total + 1
            }, options.dataField, process(page[options.dataField])));
          }

          return process(page);
        };
      };
      var onRemoved = function onRemoved(eventData) {
        return function (page) {
          var isPaginated = !!page[options.dataField];
          var process = function process(data) {
            return data.filter(function (current) {
              return eventData[options.idField] !== current[options.idField];
            });
          };

          if (isPaginated) {
            return Object.assign({}, page, _defineProperty({
              total: matches(eventData) ? page.total - 1 : page.total
            }, options.dataField, process(page[options.dataField])));
          }

          return process(page);
        };
      };
      var onUpdated = function onUpdated(eventData) {
        return function (page) {
          var isPaginated = !!page[options.dataField];
          var length = isPaginated ? page[options.dataField].length : page.length;
          var process = function process(data) {
            return data.filter(function (current) {
              return eventData[options.idField] !== current[options.idField];
            }).concat(eventData).filter(matches);
          };

          if (isPaginated) {
            var processed = process(page[options.dataField]);
            return Object.assign({}, page, _defineProperty({
              // Total can be either decreased or increased based
              // on if the update removed or added the item to the list
              total: page.total - (length - processed.length)
            }, options.dataField, processed));
          }

          return process(page);
        };
      };

      return source.concat(source.exhaustMap(function (data) {
        return _Observable.Observable.merge(_this2.created$.filter(matches).map(onCreated), _this2.removed$.map(onRemoved), _Observable.Observable.merge(_this2.updated$, _this2.patched$).map(onUpdated)).scan(function (current, callback) {
          return sortAndTrim(callback(current));
        }, data);
      }));
    }
  };
};