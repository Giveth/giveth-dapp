{
  "language": "Solidity",
  "sources": {
    "./contracts/LPPDacFactory.sol": {
      "keccak256": "0x96c8f6cd186568c02c5e5e14680bd80ce9ecd36974fb29cb8186fe79fa57e2a6",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/contracts/LPPDacFactory.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./LPPDac.sol\";\nimport \"minimetoken/contracts/MiniMeToken.sol\";\nimport \"@aragon/os/contracts/factory/AppProxyFactory.sol\";\nimport \"@aragon/os/contracts/kernel/Kernel.sol\";\nimport \"@aragon/os/contracts/acl/ACL.sol\";\nimport \"giveth-liquidpledging/contracts/LiquidPledging.sol\";\nimport \"giveth-liquidpledging/contracts/LPConstants.sol\";\nimport \"giveth-common-contracts/contracts/Escapable.sol\";\n\n\ncontract LPPDacFactory is LPConstants, Escapable, AppProxyFactory {\n    Kernel public kernel;\n    MiniMeTokenFactory public tokenFactory;\n\n    bytes32 constant public DAC_APP_ID = keccak256(\"lpp-dac\");\n    bytes32 constant public DAC_APP = keccak256(APP_BASES_NAMESPACE, DAC_APP_ID);\n    bytes32 constant public LP_APP_INSTANCE = keccak256(APP_ADDR_NAMESPACE, LP_APP_ID);\n\n    event DeployDac(address dac);\n\n    function LPPDacFactory(address _kernel, address _tokenFactory, address _escapeHatchCaller, address _escapeHatchDestination)\n        Escapable(_escapeHatchCaller, _escapeHatchDestination) public\n    {\n        // note: this contract will need CREATE_PERMISSIONS_ROLE on the ACL\n        // and the PLUGIN_MANAGER_ROLE on liquidPledging,\n        // the DAC_APP and LP_APP_INSTANCE need to be registered with the kernel\n\n        require(_kernel != 0x0);\n        require(_tokenFactory != 0x0);\n        kernel = Kernel(_kernel);\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\n    }\n\n    function newDac(\n        string name,\n        string url,\n        uint64 commitTime,\n        string tokenName,\n        string tokenSymbol,\n        address escapeHatchCaller,\n        address escapeHatchDestination\n    ) public\n    { \n        // TODO: could make MiniMeToken an AragonApp to save gas by deploying a proxy\n        address token = new MiniMeToken(tokenFactory, 0x0, 0, tokenName, 18, tokenSymbol, false);\n        newDac(name, url, commitTime, token, escapeHatchCaller, escapeHatchDestination);\n    }\n\n    function newDac(\n        string name,\n        string url,\n        uint64 commitTime,\n        address _token,\n        address escapeHatchCaller,\n        address escapeHatchDestination\n    ) public\n    {\n        address dacBase = kernel.getApp(DAC_APP);\n        require(dacBase != 0);\n        address liquidPledging = kernel.getApp(LP_APP_INSTANCE);\n        require(liquidPledging != 0);\n\n        LPPDac dac = LPPDac(newAppProxy(kernel, DAC_APP_ID));\n\n        LiquidPledging(liquidPledging).addValidPluginInstance(address(dac));\n\n        dac.initialize(liquidPledging, _token, name, url, commitTime, escapeHatchDestination);\n        MiniMeToken(_token).changeController(address(dac));\n\n        ACL acl = ACL(kernel.acl());\n\n        bytes32 hatchCallerRole = dac.ESCAPE_HATCH_CALLER_ROLE();\n        bytes32 adminRole = dac.ADMIN_ROLE();\n\n        // this permission is managed by the escapeHatchCaller\n        acl.createPermission(escapeHatchCaller, address(dac), hatchCallerRole, escapeHatchCaller);\n        // this permission is managed by msg.sender\n        acl.createPermission(msg.sender, address(dac), adminRole, msg.sender);\n\n        DeployDac(address(dac));\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/ILiquidPledgingPlugin.sol": {
      "keccak256": "0x5428d88ef6856b67f0d3271065542aa4b7e6d73428b35bf1b434e5f507d3b88b",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/ILiquidPledgingPlugin.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\n/*\n    Copyright 2017, Jordi Baylina\n    Contributors: Adri√† Massanet <adria@codecontext.io>, RJ Ewing, Griff\n    Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/// @dev `ILiquidPledgingPlugin` is the basic interface for any\n///  liquid pledging plugin\ncontract ILiquidPledgingPlugin {\n\n    /// @notice Plugins are used (much like web hooks) to initiate an action\n    ///  upon any donation, delegation, or transfer; this is an optional feature\n    ///  and allows for extreme customization of the contract. This function\n    ///  implements any action that should be initiated before a transfer.\n    /// @param pledgeManager The admin or current manager of the pledge\n    /// @param pledgeFrom This is the Id from which value will be transfered.\n    /// @param pledgeTo This is the Id that value will be transfered to.    \n    /// @param context The situation that is triggering the plugin:\n    ///  0 -> Plugin for the owner transferring pledge to another party\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\n    ///  ...\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n    ///\n    ///  256 -> Plugin for the owner receiving pledge to another party\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\n    ///  ...\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n    /// @param amount The amount of value that will be transfered.\n    function beforeTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount ) public returns (uint maxAllowed);\n\n    /// @notice Plugins are used (much like web hooks) to initiate an action\n    ///  upon any donation, delegation, or transfer; this is an optional feature\n    ///  and allows for extreme customization of the contract. This function\n    ///  implements any action that should be initiated after a transfer.\n    /// @param pledgeManager The admin or current manager of the pledge\n    /// @param pledgeFrom This is the Id from which value will be transfered.\n    /// @param pledgeTo This is the Id that value will be transfered to.    \n    /// @param context The situation that is triggering the plugin:\n    ///  0 -> Plugin for the owner transferring pledge to another party\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\n    ///  ...\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n    ///\n    ///  256 -> Plugin for the owner receiving pledge to another party\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\n    ///  ...\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n    ///  @param amount The amount of value that will be transfered.\n    function afterTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount\n    ) public;\n}\n"
    },
    "giveth-liquidpledging/contracts/LiquidPledgingStorage.sol": {
      "keccak256": "0x81ef504efbc50c58acec1b85784d9be3cb0bd761b3e9d013b19aa5f0d5169a08",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/LiquidPledgingStorage.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./ILiquidPledgingPlugin.sol\";\n\n/// @dev This is an interface for `LPVault` which serves as a secure storage for\n///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes\n///  payments can Pledges be converted for ETH\ninterface ILPVault {\n    function authorizePayment(bytes32 _ref, address _dest, address _token, uint _amount) public;\n}\n\n/// This contract contains all state variables used in LiquidPledging contracts\n/// This is done to have everything in 1 location, b/c state variable layout\n/// is MUST have be the same when performing an upgrade.\ncontract LiquidPledgingStorage {\n    enum PledgeAdminType { Giver, Delegate, Project }\n    enum PledgeState { Pledged, Paying, Paid }\n\n    /// @dev This struct defines the details of a `PledgeAdmin` which are \n    ///  commonly referenced by their index in the `admins` array\n    ///  and can own pledges and act as delegates\n    struct PledgeAdmin { \n        PledgeAdminType adminType; // Giver, Delegate or Project\n        address addr; // Account or contract address for admin\n        uint64 commitTime;  // In seconds, used for time Givers' & Delegates' have to veto\n        uint64 parentProject;  // Only for projects\n        bool canceled;      //Always false except for canceled projects\n\n        /// @dev if the plugin is 0x0 then nothing happens, if its an address\n        // than that smart contract is called when appropriate\n        ILiquidPledgingPlugin plugin; \n        string name;\n        string url;  // Can be IPFS hash\n    }\n\n    struct Pledge {\n        uint amount;\n        uint64[] delegationChain; // List of delegates in order of authority\n        uint64 owner; // PledgeAdmin\n        uint64 intendedProject; // Used when delegates are sending to projects\n        uint64 commitTime;  // When the intendedProject will become the owner\n        uint64 oldPledge; // Points to the id that this Pledge was derived from\n        address token;\n        PledgeState pledgeState; //  Pledged, Paying, Paid\n    }\n\n    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin\n    Pledge[] pledges;\n    /// @dev this mapping allows you to search for a specific pledge's \n    ///  index number by the hash of that pledge\n    mapping (bytes32 => uint64) hPledge2idx;\n\n    // this whitelist is for non-proxied plugins\n    mapping (bytes32 => bool) pluginContractWhitelist;\n    // this whitelist is for proxied plugins\n    mapping (address => bool) pluginInstanceWhitelist;\n    bool public whitelistDisabled = false;\n\n    ILPVault public vault;\n\n    // reserve 50 slots for future upgrades. I'm not sure if this is necessary \n    // but b/c of multiple inheritance used in lp, better safe then sorry.\n    // especially since it is free\n    uint[50] private storageOffset;\n}"
    },
    "@aragon/os/contracts/acl/IACL.sol": {
      "keccak256": "0xa120fc32d8d2c5096d605b0fe012d5b1e4a62118952a25a18bac5210f4fceede",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/acl/IACL.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IACL {\n    function initialize(address permissionsCreator) public;\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}\n"
    },
    "@aragon/os/contracts/kernel/IKernel.sol": {
      "keccak256": "0xc4bd88d7355351f68614906f04d7a67b4fcd81b28112f75df090b7eb8b93c881",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/kernel/IKernel.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../acl/IACL.sol\";\n\ninterface IKernel {\n    event SetApp(bytes32 indexed namespace, bytes32 indexed name, bytes32 indexed id, address app);\n\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 name, address app) public returns (bytes32 id);\n    function getApp(bytes32 id) public view returns (address);\n}"
    },
    "@aragon/os/contracts/apps/AppStorage.sol": {
      "keccak256": "0x8b9205a3fdf9d94fb1461d2c2d32335803122aa75d3fa8cf0b982796fd040c25",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/apps/AppStorage.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppStorage {\n    IKernel public kernel;\n    bytes32 public appId;\n    address internal pinnedCode; // used by Proxy Pinned\n    uint256 internal initializationBlock; // used by Initializable\n    uint256[95] private storageOffset; // forces App storage to start at after 100 slots\n    uint256 private offset;\n}\n"
    },
    "@aragon/os/contracts/common/Initializable.sol": {
      "keccak256": "0x07ef04e0cf56217c5e103a760dd577a7fffa06ca166dc15af35b3895e58880e9",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/common/Initializable.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../apps/AppStorage.sol\";\n\n\ncontract Initializable is AppStorage {\n    modifier onlyInit {\n        require(initializationBlock == 0);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        initializationBlock = getBlockNumber();\n    }\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol": {
      "keccak256": "0x6a4beed810085f11cda9d50c3547ac4cc2100d9dc18ab4982ff11dd483410012",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IEVMScriptExecutor {\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n}\n"
    },
    "@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol": {
      "keccak256": "0xa0cf92b96ee915266c74d42f3479ee809754264cc783fe9635f74d3795c7b2e1",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract EVMScriptRegistryConstants {\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = keccak256(\"evmreg.aragonpm.eth\");\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP = keccak256(keccak256(\"app\"), EVMSCRIPT_REGISTRY_APP_ID);\n}\n\n\ninterface IEVMScriptRegistry {\n    function addScriptExecutor(address executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    function getScriptExecutor(bytes script) public view returns (address);\n}"
    },
    "@aragon/os/contracts/evmscript/ScriptHelpers.sol": {
      "keccak256": "0x21a99d2fc9de2244829954ea1c21057f25f74a23f18ac7f7402420922e287517",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\nlibrary ScriptHelpers {\n    // To test with JS and compare with actual encoder. Maintaining for reference.\n    // t = function() { return IEVMScriptExecutor.at('0x4bcdd59d6c77774ee7317fc1095f69ec84421e49').contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\n    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\n    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\n\n    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\n        return encode(_a, _b, _c);\n    }\n\n    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\n        // A is positioned after the 3 position words\n        uint256 aPosition = 0x60;\n        uint256 bPosition = aPosition + 32 * abiLength(_a);\n        uint256 cPosition = bPosition + 32 * abiLength(_b);\n        uint256 length = cPosition + 32 * abiLength(_c);\n\n        d = new bytes(length);\n        assembly {\n            // Store positions\n            mstore(add(d, 0x20), aPosition)\n            mstore(add(d, 0x40), bPosition)\n            mstore(add(d, 0x60), cPosition)\n        }\n\n        // Copy memory to correct position\n        copy(d, getPtr(_a), aPosition, _a.length);\n        copy(d, getPtr(_b), bPosition, _b.length);\n        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\n    }\n\n    function abiLength(bytes memory _a) internal pure returns (uint256) {\n        // 1 for length +\n        // memory words + 1 if not divisible for 32 to offset word\n        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\n    }\n\n    function abiLength(address[] _a) internal pure returns (uint256) {\n        // 1 for length + 1 per item\n        return 1 + _a.length;\n    }\n\n    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\n        uint dest;\n        assembly {\n            dest := add(add(_d, 0x20), _pos)\n        }\n        memcpy(dest, _src, _length + 32);\n    }\n\n    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getSpecId(bytes _script) internal pure returns (uint32) {\n        return uint32At(_script, 0);\n    }\n\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := mload(add(_data, add(0x20, _location)))\n        }\n    }\n\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n            0x1000000000000000000000000)\n        }\n    }\n\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n            0x100000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := add(_data, add(0x20, _location))\n        }\n    }\n\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n        bytes memory payload = new bytes(4);\n        payload[0] = bytes1(_sig);\n        payload[1] = bytes1(_sig << 8);\n        payload[2] = bytes1(_sig << 16);\n        payload[3] = bytes1(_sig << 24);\n        return payload;\n    }\n\n    function memcpy(uint _dest, uint _src, uint _len) public pure {\n        uint256 src = _src;\n        uint256 dest = _dest;\n        uint256 len = _len;\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}"
    },
    "@aragon/os/contracts/evmscript/EVMScriptRunner.sol": {
      "keccak256": "0xf226f2c5c0a930340d49a5f79ac49a18dc0f88632acdef32c4eb698d5bb8a77e",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../apps/AppStorage.sol\";\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"./ScriptHelpers.sol\";\n\n\ncontract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {\n    using ScriptHelpers for bytes;\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {\n        // TODO: Too much data flying around, maybe extracting spec id here is cheaper\n        address executorAddr = getExecutor(_script);\n        require(executorAddr != address(0));\n\n        bytes memory calldataArgs = _script.encode(_input, _blacklist);\n        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;\n\n        require(executorAddr.delegatecall(sig, calldataArgs));\n\n        return returnedDataDecoded();\n    }\n\n    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));\n    }\n\n    // TODO: Internal\n    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    /**\n    * @dev copies and returns last's call data. Needs to ABI decode first\n    */\n    function returnedDataDecoded() internal view returns (bytes ret) {\n        assembly {\n            let size := returndatasize\n            switch size\n            case 0 {}\n            default {\n                ret := mload(0x40) // free mem ptr get\n                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data\n            }\n        }\n        return ret;\n    }\n\n    modifier protectState {\n        address preKernel = kernel;\n        bytes32 preAppId = appId;\n        _; // exec\n        require(kernel == preKernel);\n        require(appId == preAppId);\n    }\n}"
    },
    "@aragon/os/contracts/acl/ACLSyntaxSugar.sol": {
      "keccak256": "0x92c85fe20e03c5fde11c3006b2acd7c24021d53356bd14070522d71912e5419b",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract ACLSyntaxSugar {\n    function arr() internal pure returns (uint256[] r) {}\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}\n\n\ncontract ACLHelpers {\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/AragonApp.sol": {
      "keccak256": "0x7b5ed0ab203aea14886f337bc8b73ec49177415d43b3251d917d51a6d138d8f1",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/apps/AragonApp.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./AppStorage.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../evmscript/EVMScriptRunner.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\n\n\ncontract AragonApp is AppStorage, Initializable, ACLSyntaxSugar, EVMScriptRunner {\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)));\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] params) {\n        require(canPerform(msg.sender, _role, params));\n        _;\n    }\n\n    function canPerform(address _sender, bytes32 _role, uint256[] params) public view returns (bool) {\n        bytes memory how; // no need to init memory as it is never used\n        if (params.length > 0) {\n            uint256 byteLength = params.length * 32;\n            assembly {\n                how := params // forced casting\n                mstore(how, byteLength)\n            }\n        }\n        return address(kernel) == 0 || kernel.hasPermission(_sender, address(this), _role, how);\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/LiquidPledgingACLHelpers.sol": {
      "keccak256": "0xb675a7a788bf656d4c3c78f3b4cf6645afb432939d1a4c38d70e01d068b0ce62",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/LiquidPledgingACLHelpers.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\ncontract LiquidPledgingACLHelpers {\n    function arr(uint64 a, uint64 b, address c, uint d, address e) internal pure returns(uint[] r) {\n        r = new uint[](4);\n        r[0] = uint(a);\n        r[1] = uint(b);\n        r[2] = uint(c);\n        r[3] = d;\n        r[4] = uint(e);\n    }\n\n    function arr(bool a) internal pure returns (uint[] r) {\n        r = new uint[](1);\n        uint _a;\n        assembly {\n            _a := a // forced casting\n        }\n        r[0] = _a;\n    }\n}"
    },
    "giveth-liquidpledging/contracts/LiquidPledgingPlugins.sol": {
      "keccak256": "0xb3566dfb5a8a1a0a57952501f6ddc39974fff2ee4c2861b20342a95b442cc776",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/LiquidPledgingPlugins.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"./LiquidPledgingStorage.sol\";\nimport \"./LiquidPledgingACLHelpers.sol\";\n\ncontract LiquidPledgingPlugins is AragonApp, LiquidPledgingStorage, LiquidPledgingACLHelpers {\n\n    bytes32 constant public PLUGIN_MANAGER_ROLE = keccak256(\"PLUGIN_MANAGER_ROLE\");\n\n    function addValidPluginInstance(address addr) auth(PLUGIN_MANAGER_ROLE) external {\n        pluginInstanceWhitelist[addr] = true;\n    }\n\n    function addValidPluginContract(bytes32 contractHash) auth(PLUGIN_MANAGER_ROLE) public {\n        pluginContractWhitelist[contractHash] = true;\n    }\n\n    function addValidPluginContracts(bytes32[] contractHashes) external auth(PLUGIN_MANAGER_ROLE) {\n        for (uint8 i = 0; i < contractHashes.length; i++) {\n            addValidPluginContract(contractHashes[i]);\n        }\n    }\n\n    function removeValidPluginContract(bytes32 contractHash) external authP(PLUGIN_MANAGER_ROLE, arr(contractHash)) {\n        pluginContractWhitelist[contractHash] = false;\n    }\n\n    function removeValidPluginInstance(address addr) external authP(PLUGIN_MANAGER_ROLE, arr(addr)) {\n        pluginInstanceWhitelist[addr] = false;\n    }\n\n    function useWhitelist(bool useWhitelist) external auth(PLUGIN_MANAGER_ROLE) {\n        whitelistDisabled = !useWhitelist;\n    }\n\n    function isValidPlugin(address addr) public view returns(bool) {\n        if (whitelistDisabled || addr == 0x0) {\n            return true;\n        }\n\n        // first check pluginInstances\n        if (pluginInstanceWhitelist[addr]) {\n            return true;\n        }\n\n        // if the addr isn't a valid instance, check the contract code\n        bytes32 contractHash = getCodeHash(addr);\n\n        return pluginContractWhitelist[contractHash];\n    }\n\n    function getCodeHash(address addr) public view returns(bytes32) {\n        bytes memory o_code;\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(addr)\n            // allocate output byte array - this could also be done without assembly\n            // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n            mstore(o_code, size) // store length in memory\n            // actually retrieve the code, this needs assembly\n            extcodecopy(addr, add(o_code, 0x20), 0, size)\n        }\n        return keccak256(o_code);\n    }\n}"
    },
    "giveth-liquidpledging/contracts/PledgeAdmins.sol": {
      "keccak256": "0xfa7101ced06daaf446ff10e222aafb68a0d52dca99f57d6c8d7aab959e6a5104",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/PledgeAdmins.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport \"./LiquidPledgingPlugins.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\ncontract PledgeAdmins is AragonApp, LiquidPledgingPlugins {\n\n    // Limits inserted to prevent large loops that could prevent canceling\n    uint constant MAX_SUBPROJECT_LEVEL = 20;\n    uint constant MAX_INTERPROJECT_LEVEL = 20;\n\n    // Events\n    event GiverAdded(uint64 indexed idGiver, string url);\n    event GiverUpdated(uint64 indexed idGiver, string url);\n    event DelegateAdded(uint64 indexed idDelegate, string url);\n    event DelegateUpdated(uint64 indexed idDelegate, string url);\n    event ProjectAdded(uint64 indexed idProject, string url);\n    event ProjectUpdated(uint64 indexed idProject, string url);\n\n////////////////////\n// Public functions\n////////////////////\n\n    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address\n    /// @param name The name used to identify the Giver\n    /// @param url The link to the Giver's profile often an IPFS hash\n    /// @param commitTime The length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    /// @param plugin This is Giver's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idGiver The id number used to reference this Admin\n    function addGiver(\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idGiver)\n    {\n        return addGiver(\n            msg.sender,\n            name,\n            url,\n            commitTime,\n            plugin\n        );\n    }\n\n    // TODO: is there an issue w/ allowing anyone to create a giver on behalf of another addy?\n    function addGiver(\n        address addr,\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) public returns (uint64 idGiver)\n    {\n        require(isValidPlugin(plugin)); // Plugin check\n\n        idGiver = uint64(admins.length);\n\n        // Save the fields\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Giver,\n                addr,\n                commitTime,\n                0,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        GiverAdded(idGiver, url);\n    }\n\n    /// @notice Updates a Giver's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\n    ///  by the current address of the Giver\n    /// @param idGiver This is the Admin id number used to specify the Giver\n    /// @param newAddr The new address that represents this Giver\n    /// @param newName The new name used to identify the Giver\n    /// @param newUrl The new link to the Giver's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    function updateGiver(\n        uint64 idGiver,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage giver = _findAdmin(idGiver);\n        require(msg.sender == giver.addr);\n        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver\n        giver.addr = newAddr;\n        giver.name = newName;\n        giver.url = newUrl;\n        giver.commitTime = newCommitTime;\n\n        GiverUpdated(idGiver, newUrl);\n    }\n\n    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr\n    /// @param name The name used to identify the Delegate\n    /// @param url The link to the Delegate's profile often an IPFS hash\n    /// @param commitTime Sets the length of time in seconds that this delegate\n    ///  can be vetoed. Whenever this delegate is in a delegate chain the time\n    ///  allowed to veto any event must be greater than or equal to this time.\n    /// @param plugin This is Delegate's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idxDelegate The id number used to reference this Delegate within\n    ///  the PLEDGE_ADMIN array\n    function addDelegate(\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idDelegate) \n    {\n        require(isValidPlugin(plugin)); // Plugin check\n\n        idDelegate = uint64(admins.length);\n\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Delegate,\n                msg.sender,\n                commitTime,\n                0,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        DelegateAdded(idDelegate, url);\n    }\n\n    /// @notice Updates a Delegate's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\n    ///  by the current address of the Delegate\n    /// @param idDelegate The Admin id number used to specify the Delegate\n    /// @param newAddr The new address that represents this Delegate\n    /// @param newName The new name used to identify the Delegate\n    /// @param newUrl The new link to the Delegate's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds that this\n    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain\n    ///  the time allowed to veto any event must be greater than or equal to\n    ///  this time.\n    function updateDelegate(\n        uint64 idDelegate,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage delegate = _findAdmin(idDelegate);\n        require(msg.sender == delegate.addr);\n        require(delegate.adminType == PledgeAdminType.Delegate);\n        delegate.addr = newAddr;\n        delegate.name = newName;\n        delegate.url = newUrl;\n        delegate.commitTime = newCommitTime;\n\n        DelegateUpdated(idDelegate, newUrl);\n    }\n\n    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr\n    /// @param name The name used to identify the Project\n    /// @param url The link to the Project's profile often an IPFS hash\n    /// @param projectAdmin The address for the trusted project manager\n    /// @param parentProject The Admin id number for the parent project or 0 if\n    ///  there is no parentProject\n    /// @param commitTime Sets the length of time in seconds the Project has to\n    ///   veto when the Project delegates to another Delegate and they pledge\n    ///   those funds to a project\n    /// @param plugin This is Project's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idProject The id number used to reference this Admin\n    function addProject(\n        string name,\n        string url,\n        address projectAdmin,\n        uint64 parentProject,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idProject) \n    {\n        require(isValidPlugin(plugin));\n\n        if (parentProject != 0) {\n            PledgeAdmin storage a = _findAdmin(parentProject);\n            // getProjectLevel will check that parentProject has a `Project` adminType\n            require(_getProjectLevel(a) < MAX_SUBPROJECT_LEVEL);\n        }\n\n        idProject = uint64(admins.length);\n\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Project,\n                projectAdmin,\n                commitTime,\n                parentProject,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        ProjectAdded(idProject, url);\n    }\n\n    /// @notice Updates a Project's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin or a parentProject,\n    ///  and it must be called by the current address of the Project\n    /// @param idProject The Admin id number used to specify the Project\n    /// @param newAddr The new address that represents this Project\n    /// @param newName The new name used to identify the Project\n    /// @param newUrl The new link to the Project's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds the Project has\n    ///  to veto when the Project delegates to a Delegate and they pledge those\n    ///  funds to a project\n    function updateProject(\n        uint64 idProject,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage project = _findAdmin(idProject);\n\n        require(msg.sender == project.addr);\n        require(project.adminType == PledgeAdminType.Project);\n\n        project.addr = newAddr;\n        project.name = newName;\n        project.url = newUrl;\n        project.commitTime = newCommitTime;\n\n        ProjectUpdated(idProject, newUrl);\n    }\n\n/////////////////////////////\n// Public constant functions\n/////////////////////////////\n\n    /// @notice A constant getter used to check how many total Admins exist\n    /// @return The total number of admins (Givers, Delegates and Projects) .\n    function numberOfPledgeAdmins() external view returns(uint) {\n        return admins.length - 1;\n    }\n\n    /// @notice A constant getter to check the details of a specified Admin\n    /// @return addr Account or contract address for admin\n    /// @return name Name of the pledgeAdmin\n    /// @return url The link to the Project's profile often an IPFS hash\n    /// @return commitTime The length of time in seconds the Admin has to veto\n    ///   when the Admin delegates to a Delegate and that Delegate pledges those\n    ///   funds to a project\n    /// @return parentProject The Admin id number for the parent project or 0\n    ///  if there is no parentProject\n    /// @return canceled 0 for Delegates & Givers, true if a Project has been\n    ///  canceled\n    /// @return plugin This is Project's liquidPledging plugin allowing for\n    ///  extended functionality\n    function getPledgeAdmin(uint64 idAdmin) external view returns (\n        PledgeAdminType adminType,\n        address addr,\n        string name,\n        string url,\n        uint64 commitTime,\n        uint64 parentProject,\n        bool canceled,\n        address plugin\n    ) {\n        PledgeAdmin storage a = _findAdmin(idAdmin);\n        adminType = a.adminType;\n        addr = a.addr;\n        name = a.name;\n        url = a.url;\n        commitTime = a.commitTime;\n        parentProject = a.parentProject;\n        canceled = a.canceled;\n        plugin = address(a.plugin);\n    }\n\n    /// @notice A getter to find if a specified Project has been canceled\n    /// @param projectId The Admin id number used to specify the Project\n    /// @return True if the Project has been canceled\n    function isProjectCanceled(uint64 projectId)\n        public view returns (bool)\n    {\n        PledgeAdmin storage a = _findAdmin(projectId);\n\n        if (a.adminType == PledgeAdminType.Giver) {\n            return false;\n        }\n\n        assert(a.adminType == PledgeAdminType.Project);\n\n        if (a.canceled) {\n            return true;\n        }\n        if (a.parentProject == 0) {\n            return false;\n        }\n\n        return isProjectCanceled(a.parentProject);\n    }\n\n///////////////////\n// Internal methods\n///////////////////\n\n    /// @notice A getter to look up a Admin's details\n    /// @param idAdmin The id for the Admin to lookup\n    /// @return The PledgeAdmin struct for the specified Admin\n    function _findAdmin(uint64 idAdmin) internal view returns (PledgeAdmin storage) {\n        require(idAdmin < admins.length);\n        return admins[idAdmin];\n    }\n\n    /// @notice Find the level of authority a specific Project has\n    ///  using a recursive loop\n    /// @param a The project admin being queried\n    /// @return The level of authority a specific Project has\n    function _getProjectLevel(PledgeAdmin a) internal view returns(uint64) {\n        assert(a.adminType == PledgeAdminType.Project);\n\n        if (a.parentProject == 0) {\n            return(1);\n        }\n\n        PledgeAdmin storage parent = _findAdmin(a.parentProject);\n        return _getProjectLevel(parent) + 1;\n    }\n}"
    },
    "giveth-liquidpledging/contracts/Pledges.sol": {
      "keccak256": "0x9c7a60dff92f94d518d0c4a40d5434cd23680f79fd364ae855575ae4ca683797",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/Pledges.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"./LiquidPledgingStorage.sol\";\n\ncontract Pledges is AragonApp, LiquidPledgingStorage {\n\n    // Limits inserted to prevent large loops that could prevent canceling\n    uint constant MAX_DELEGATES = 10;\n\n    // a constant for when a delegate is requested that is not in the system\n    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;\n\n/////////////////////////////\n// Public constant functions\n////////////////////////////\n\n    /// @notice A constant getter that returns the total number of pledges\n    /// @return The total number of Pledges in the system\n    function numberOfPledges() external view returns (uint) {\n        return pledges.length - 1;\n    }\n\n    /// @notice A getter that returns the details of the specified pledge\n    /// @param idPledge the id number of the pledge being queried\n    /// @return the amount, owner, the number of delegates (but not the actual\n    ///  delegates, the intendedProject (if any), the current commit time and\n    ///  the previous pledge this pledge was derived from\n    function getPledge(uint64 idPledge) external view returns(\n        uint amount,\n        uint64 owner,\n        uint64 nDelegates,\n        uint64 intendedProject,\n        uint64 commitTime,\n        uint64 oldPledge,\n        address token,\n        PledgeState pledgeState\n    ) {\n        Pledge memory p = _findPledge(idPledge);\n        amount = p.amount;\n        owner = p.owner;\n        nDelegates = uint64(p.delegationChain.length);\n        intendedProject = p.intendedProject;\n        commitTime = p.commitTime;\n        oldPledge = p.oldPledge;\n        token = p.token;\n        pledgeState = p.pledgeState;\n    }\n\n\n////////////////////\n// Internal methods\n////////////////////\n\n    /// @notice This creates a Pledge with an initial amount of 0 if one is not\n    ///  created already; otherwise it finds the pledge with the specified\n    ///  attributes; all pledges technically exist, if the pledge hasn't been\n    ///  created in this system yet it simply isn't in the hash array\n    ///  hPledge2idx[] yet\n    /// @param owner The owner of the pledge being looked up\n    /// @param delegationChain The list of delegates in order of authority\n    /// @param intendedProject The project this pledge will Fund after the\n    ///  commitTime has passed\n    /// @param commitTime The length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    /// @param oldPledge This value is used to store the pledge the current\n    ///  pledge was came from, and in the case a Project is canceled, the Pledge\n    ///  will revert back to it's previous state\n    /// @param state The pledge state: Pledged, Paying, or state\n    /// @return The hPledge2idx index number\n    function _findOrCreatePledge(\n        uint64 owner,\n        uint64[] delegationChain,\n        uint64 intendedProject,\n        uint64 commitTime,\n        uint64 oldPledge,\n        address token,\n        PledgeState state\n    ) internal returns (uint64)\n    {\n        bytes32 hPledge = keccak256(delegationChain, owner, intendedProject, commitTime, oldPledge, token, state);\n        uint64 id = hPledge2idx[hPledge];\n        if (id > 0) {\n            return id;\n        }\n\n        id = uint64(pledges.length);\n        hPledge2idx[hPledge] = id;\n        pledges.push(\n            Pledge(\n                0,\n                delegationChain,\n                owner,\n                intendedProject,\n                commitTime,\n                oldPledge,\n                token,\n                state\n            )\n        );\n        return id;\n    }\n\n    /// @param idPledge the id of the pledge to load from storage\n    /// @return The Pledge\n    function _findPledge(uint64 idPledge) internal view returns(Pledge storage) {\n        require(idPledge < pledges.length);\n        return pledges[idPledge];\n    }\n\n    /// @notice A getter that searches the delegationChain for the level of\n    ///  authority a specific delegate has within a Pledge\n    /// @param p The Pledge that will be searched\n    /// @param idDelegate The specified delegate that's searched for\n    /// @return If the delegate chain contains the delegate with the\n    ///  `admins` array index `idDelegate` this returns that delegates\n    ///  corresponding index in the delegationChain. Otherwise it returns\n    ///  the NOTFOUND constant\n    function _getDelegateIdx(Pledge p, uint64 idDelegate) internal pure returns(uint64) {\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            if (p.delegationChain[i] == idDelegate) {\n                return uint64(i);\n            }\n        }\n        return NOTFOUND;\n    }\n\n    /// @notice A getter to find how many old \"parent\" pledges a specific Pledge\n    ///  had using a self-referential loop\n    /// @param p The Pledge being queried\n    /// @return The number of old \"parent\" pledges a specific Pledge had\n    function _getPledgeLevel(Pledge p) internal view returns(uint) {\n        if (p.oldPledge == 0) {\n            return 0;\n        }\n        Pledge storage oldP = _findPledge(p.oldPledge);\n        return _getPledgeLevel(oldP) + 1; // a loop lookup\n    }\n}\n"
    },
    "giveth-common-contracts/contracts/ERC20.sol": {
      "keccak256": "0xcadd92ef9521600699043b047147e61718c62af07911731d77890dd47fc1a512",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-common-contracts/contracts/ERC20.sol"
      ],
      "content": "pragma solidity ^0.4.15;\n\n\n/**\n * @title ERC20\n * @dev A standard interface for tokens.\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n */\ncontract ERC20 {\n  \n    /// @dev Returns the total token supply\n    function totalSupply() public constant returns (uint256 supply);\n\n    /// @dev Returns the account balance of the account with address _owner\n    function balanceOf(address _owner) public constant returns (uint256 balance);\n\n    /// @dev Transfers _value number of tokens to address _to\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @dev Transfers _value number of tokens from address _from to address _to\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n"
    },
    "giveth-liquidpledging/contracts/EscapableApp.sol": {
      "keccak256": "0x03817336f5fa2d4211b9b5bb0beb6e5b2ad69061eb2b26e4e2d0bc04f486917a",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/EscapableApp.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n/*\n    Copyright 2016, Jordi Baylina\n    Contributor: Adri√† Massanet <adria@codecontext.io>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// import \"./Owned.sol\";\nimport \"giveth-common-contracts/contracts/ERC20.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\n\n/// @dev `EscapableApp` is a base level contract; it creates an escape hatch\n///  function that can be called in an\n///  emergency that will allow designated addresses to send any ether or tokens\n///  held in the contract to an `escapeHatchDestination` as long as they were\n///  not blacklisted\ncontract EscapableApp is AragonApp {\n    // warning whoever has this role can move all funds to the `escapeHatchDestination`\n    bytes32 constant public ESCAPE_HATCH_CALLER_ROLE = keccak256(\"ESCAPE_HATCH_CALLER_ROLE\");\n\n    event EscapeHatchBlackistedToken(address token);\n    event EscapeHatchCalled(address token, uint amount);\n\n    address public escapeHatchDestination;\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\n    uint[20] private storageOffset; // reserve 20 slots for future upgrades\n\n    function EscapableApp(address _escapeHatchDestination) public {\n        _init(_escapeHatchDestination);\n    }\n\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract; if a neutral address\n    ///  is required, the WHG Multisig is an option:\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n    function initialize(address _escapeHatchDestination) onlyInit public {\n        _init(_escapeHatchDestination);\n    }\n\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\n    /// security issue is uncovered or something unexpected happened\n    /// @param _token to transfer, use 0x0 for ether\n    function escapeHatch(address _token) external authP(ESCAPE_HATCH_CALLER_ROLE, arr(_token)) {\n        require(escapeBlacklist[_token]==false);\n\n        uint256 balance;\n\n        /// @dev Logic for ether\n        if (_token == 0x0) {\n            balance = this.balance;\n            escapeHatchDestination.transfer(balance);\n            EscapeHatchCalled(_token, balance);\n            return;\n        }\n        /// @dev Logic for tokens\n        ERC20 token = ERC20(_token);\n        balance = token.balanceOf(this);\n        require(token.transfer(escapeHatchDestination, balance));\n        EscapeHatchCalled(_token, balance);\n    }\n\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\n    /// @param _token the token address being queried\n    /// @return False if `_token` is in the blacklist and can't be taken out of\n    ///  the contract via the `escapeHatch()`\n    function isTokenEscapable(address _token) view external returns (bool) {\n        return !escapeBlacklist[_token];\n    }\n\n    function _init(address _escapeHatchDestination) internal {\n        initialized();\n        require(_escapeHatchDestination != 0x0);\n\n        escapeHatchDestination = _escapeHatchDestination;\n    }\n\n    /// @notice Creates the blacklist of tokens that are not able to be taken\n    ///  out of the contract; can only be done at the deployment, and the logic\n    ///  to add to the blacklist will be in the constructor of a child contract\n    /// @param _token the token contract address that is to be blacklisted \n    function _blacklistEscapeToken(address _token) internal {\n        escapeBlacklist[_token] = true;\n        EscapeHatchBlackistedToken(_token);\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/LiquidPledgingBase.sol": {
      "keccak256": "0xc6bfc0886e82d9896a4aac941fc666536dc3f6e28f0a2f2ef486a1e12fce0aa5",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/LiquidPledgingBase.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina\n    Contributors: Adri√† Massanet <adria@codecontext.io>, RJ Ewing, Griff\n    Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledgingStorage.sol\";\nimport \"./PledgeAdmins.sol\";\nimport \"./Pledges.sol\";\nimport \"./EscapableApp.sol\";\n\n/// @dev `LiquidPledgingBase` is the base level contract used to carry out\n///  liquidPledging's most basic functions, mostly handling and searching the\n///  data structures\ncontract LiquidPledgingBase is EscapableApp, LiquidPledgingStorage, PledgeAdmins, Pledges {\n\n    event Transfer(uint indexed from, uint indexed to, uint amount);\n    event CancelProject(uint indexed idProject);\n\n/////////////\n// Modifiers\n/////////////\n\n    /// @dev The `vault`is the only addresses that can call a function with this\n    ///  modifier\n    modifier onlyVault() {\n        require(msg.sender == address(vault));\n        _;\n    }\n\n///////////////\n// Constructor\n///////////////\n\n    function initialize(address _escapeHatchDestination) onlyInit public {\n        require(false); // overload the EscapableApp\n        _escapeHatchDestination;\n    }\n\n    /// @param _vault The vault where the ETH backing the pledges is stored\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract; if a neutral address\n    ///  is required, the WHG Multisig is an option:\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n    function initialize(address _vault, address _escapeHatchDestination) onlyInit public {\n        super.initialize(_escapeHatchDestination);\n        require(_vault != 0x0);\n\n        vault = ILPVault(_vault);\n\n        admins.length = 1; // we reserve the 0 admin\n        pledges.length = 1; // we reserve the 0 pledge\n    }\n\n\n/////////////////////////////\n// Public constant functions\n/////////////////////////////\n\n    /// @notice Getter to find Delegate w/ the Pledge ID & the Delegate index\n    /// @param idPledge The id number representing the pledge being queried\n    /// @param idxDelegate The index number for the delegate in this Pledge \n    function getPledgeDelegate(uint64 idPledge, uint64 idxDelegate) external view returns(\n        uint64 idDelegate,\n        address addr,\n        string name\n    ) {\n        Pledge storage p = _findPledge(idPledge);\n        idDelegate = p.delegationChain[idxDelegate - 1];\n        PledgeAdmin storage delegate = _findAdmin(idDelegate);\n        addr = delegate.addr;\n        name = delegate.name;\n    }\n\n///////////////////\n// Public functions\n///////////////////\n\n    /// @notice Only affects pledges with the Pledged PledgeState for 2 things:\n    ///   #1: Checks if the pledge should be committed. This means that\n    ///       if the pledge has an intendedProject and it is past the\n    ///       commitTime, it changes the owner to be the proposed project\n    ///       (The UI will have to read the commit time and manually do what\n    ///       this function does to the pledge for the end user\n    ///       at the expiration of the commitTime)\n    ///\n    ///   #2: Checks to make sure that if there has been a cancellation in the\n    ///       chain of projects, the pledge's owner has been changed\n    ///       appropriately.\n    ///\n    /// This function can be called by anybody at anytime on any pledge.\n    ///  In general it can be called to force the calls of the affected \n    ///  plugins, which also need to be predicted by the UI\n    /// @param idPledge This is the id of the pledge that will be normalized\n    /// @return The normalized Pledge!\n    function normalizePledge(uint64 idPledge) public returns(uint64) {\n        Pledge storage p = _findPledge(idPledge);\n\n        // Check to make sure this pledge hasn't already been used \n        // or is in the process of being used\n        if (p.pledgeState != PledgeState.Pledged) {\n            return idPledge;\n        }\n\n        // First send to a project if it's proposed and committed\n        if ((p.intendedProject > 0) && ( _getTime() > p.commitTime)) {\n            uint64 oldPledge = _findOrCreatePledge(\n                p.owner,\n                p.delegationChain,\n                0,\n                0,\n                p.oldPledge,\n                p.token,\n                PledgeState.Pledged\n            );\n            uint64 toPledge = _findOrCreatePledge(\n                p.intendedProject,\n                new uint64[](0),\n                0,\n                0,\n                oldPledge,\n                p.token,\n                PledgeState.Pledged\n            );\n            _doTransfer(idPledge, toPledge, p.amount);\n            idPledge = toPledge;\n            p = _findPledge(idPledge);\n        }\n\n        toPledge = _getOldestPledgeNotCanceled(idPledge);\n        if (toPledge != idPledge) {\n            _doTransfer(idPledge, toPledge, p.amount);\n        }\n\n        return toPledge;\n    }\n\n////////////////////\n// Internal methods\n////////////////////\n\n    /// @notice A check to see if the msg.sender is the owner or the\n    ///  plugin contract for a specific Admin\n    /// @param idAdmin The id of the admin being checked\n    function _checkAdminOwner(uint64 idAdmin) internal view {\n        PledgeAdmin storage a = _findAdmin(idAdmin);\n        require(msg.sender == address(a.plugin) || msg.sender == a.addr);\n    }\n\n    function _transfer( \n        uint64 idSender,\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal\n    {\n        require(idReceiver > 0); // prevent burning value\n        idPledge = normalizePledge(idPledge);\n\n        Pledge storage p = _findPledge(idPledge);\n        PledgeAdmin storage receiver = _findAdmin(idReceiver);\n\n        require(p.pledgeState == PledgeState.Pledged);\n\n        // If the sender is the owner of the Pledge\n        if (p.owner == idSender) {\n\n            if (receiver.adminType == PledgeAdminType.Giver) {\n                _transferOwnershipToGiver(idPledge, amount, idReceiver);\n                return;\n            } else if (receiver.adminType == PledgeAdminType.Project) {\n                _transferOwnershipToProject(idPledge, amount, idReceiver);\n                return;\n            } else if (receiver.adminType == PledgeAdminType.Delegate) {\n\n                uint recieverDIdx = _getDelegateIdx(p, idReceiver);\n                if (p.intendedProject > 0 && recieverDIdx != NOTFOUND) {\n                    // if there is an intendedProject and the receiver is in the delegationChain,\n                    // then we want to preserve the delegationChain as this is a veto of the\n                    // intendedProject by the owner\n\n                    if (recieverDIdx == p.delegationChain.length - 1) {\n                        uint64 toPledge = _findOrCreatePledge(\n                            p.owner,\n                            p.delegationChain,\n                            0,\n                            0,\n                            p.oldPledge,\n                            p.token,\n                            PledgeState.Pledged);\n                        _doTransfer(idPledge, toPledge, amount);\n                        return;\n                    }\n\n                    _undelegate(idPledge, amount, p.delegationChain.length - receiverDIdx - 1);\n                    return;\n                }\n                // owner is not vetoing an intendedProject and is transferring the pledge to a delegate,\n                // so we want to reset the delegationChain\n                idPledge = _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length\n                );\n                _appendDelegate(idPledge, amount, idReceiver);\n                return;\n            }\n\n            // This should never be reached as the receiver.adminType\n            // should always be either a Giver, Project, or Delegate\n            assert(false);\n        }\n\n        // If the sender is a Delegate\n        uint senderDIdx = _getDelegateIdx(p, idSender);\n        if (senderDIdx != NOTFOUND) {\n\n            // And the receiver is another Giver\n            if (receiver.adminType == PledgeAdminType.Giver) {\n                // Only transfer to the Giver who owns the pledge\n                assert(p.owner == idReceiver);\n                _undelegate(idPledge, amount, p.delegationChain.length);\n                return;\n            }\n\n            // And the receiver is another Delegate\n            if (receiver.adminType == PledgeAdminType.Delegate) {\n                uint receiverDIdx = _getDelegateIdx(p, idReceiver);\n\n                // And not in the delegationChain\n                if (receiverDIdx == NOTFOUND) {\n                    idPledge = _undelegate(\n                        idPledge,\n                        amount,\n                        p.delegationChain.length - senderDIdx - 1\n                    );\n                    _appendDelegate(idPledge, amount, idReceiver);\n                    return;\n\n                // And part of the delegationChain and is after the sender, then\n                //  all of the other delegates after the sender are removed and\n                //  the receiver is appended at the end of the delegationChain\n                } else if (receiverDIdx > senderDIdx) {\n                    idPledge = _undelegate(\n                        idPledge,\n                        amount,\n                        p.delegationChain.length - senderDIdx - 1\n                    );\n                    _appendDelegate(idPledge, amount, idReceiver);\n                    return;\n                }\n\n                // And is already part of the delegate chain but is before the\n                //  sender, then the sender and all of the other delegates after\n                //  the RECEIVER are removed from the delegationChain\n                //TODO Check for Game Theory issues (from Arthur) this allows the sender to sort of go komakosi and remove himself and the delegates between himself and the receiver... should this authority be allowed?\n                _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length - receiverDIdx - 1\n                );\n                return;\n            }\n\n            // And the receiver is a Project, all the delegates after the sender\n            //  are removed and the amount is pre-committed to the project\n            if (receiver.adminType == PledgeAdminType.Project) {\n                idPledge = _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length - senderDIdx - 1\n                );\n                _proposeAssignProject(idPledge, amount, idReceiver);\n                return;\n            }\n        }\n        assert(false);  // When the sender is not an owner or a delegate\n    }\n\n    /// @notice `transferOwnershipToProject` allows for the transfer of\n    ///  ownership to the project, but it can also be called by a project\n    ///  to un-delegate everyone by setting one's own id for the idReceiver\n    /// @param idPledge the id of the pledge to be transfered.\n    /// @param amount Quantity of value that's being transfered\n    /// @param idReceiver The new owner of the project (or self to un-delegate)\n    function _transferOwnershipToProject(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        // Ensure that the pledge is not already at max pledge depth\n        // and the project has not been canceled\n        require(_getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n        require(!isProjectCanceled(idReceiver));\n\n        uint64 oldPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        uint64 toPledge = _findOrCreatePledge(\n            idReceiver,                     // Set the new owner\n            new uint64[](0),                // clear the delegation chain\n            0,\n            0,\n            oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }   \n\n\n    /// @notice `transferOwnershipToGiver` allows for the transfer of\n    ///  value back to the Giver, value is placed in a pledged state\n    ///  without being attached to a project, delegation chain, or time line.\n    /// @param idPledge the id of the pledge to be transferred.\n    /// @param amount Quantity of value that's being transferred\n    /// @param idReceiver The new owner of the pledge\n    function _transferOwnershipToGiver(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        uint64 toPledge = _findOrCreatePledge(\n            idReceiver,\n            new uint64[](0),\n            0,\n            0,\n            0,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\n    ///  end of the delegate chain for a given Pledge.\n    /// @param idPledge the id of the pledge thats delegate chain will be modified.\n    /// @param amount Quantity of value that's being chained.\n    /// @param idReceiver The delegate to be added at the end of the chain\n    function _appendDelegate(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.delegationChain.length < MAX_DELEGATES);\n        uint64[] memory newDelegationChain = new uint64[](\n            p.delegationChain.length + 1\n        );\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            newDelegationChain[i] = p.delegationChain[i];\n        }\n\n        // Make the last item in the array the idReceiver\n        newDelegationChain[p.delegationChain.length] = idReceiver;\n\n        uint64 toPledge = _findOrCreatePledge(\n            p.owner,\n            newDelegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\n    ///  end of the delegate chain for a given Pledge.\n    /// @param idPledge the id of the pledge thats delegate chain will be modified.\n    /// @param amount Quantity of value that's shifted from delegates.\n    /// @param q Number (or depth) of delegates to remove\n    /// @return toPledge The id for the pledge being adjusted or created\n    function _undelegate(\n        uint64 idPledge,\n        uint amount,\n        uint q\n    ) internal returns (uint64 toPledge)\n    {\n        Pledge storage p = _findPledge(idPledge);\n        uint64[] memory newDelegationChain = new uint64[](\n            p.delegationChain.length - q\n        );\n\n        for (uint i = 0; i < p.delegationChain.length - q; i++) {\n            newDelegationChain[i] = p.delegationChain[i];\n        }\n        toPledge = _findOrCreatePledge(\n            p.owner,\n            newDelegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `proposeAssignProject` proposes the assignment of a pledge\n    ///  to a specific project.\n    /// @dev This function should potentially be named more specifically.\n    /// @param idPledge the id of the pledge that will be assigned.\n    /// @param amount Quantity of value this pledge leader would be assigned.\n    /// @param idReceiver The project this pledge will potentially \n    ///  be assigned to.\n    function _proposeAssignProject(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(_getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n        require(!isProjectCanceled(idReceiver));\n\n        uint64 toPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            idReceiver,\n            uint64(_getTime() + _maxCommitTime(p)),\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `doTransfer` is designed to allow for pledge amounts to be \n    ///  shifted around internally.\n    /// @param from This is the id of the pledge from which value will be transferred.\n    /// @param to This is the id of the pledge that value will be transferred to.\n    /// @param _amount The amount of value that will be transferred.\n    function _doTransfer(uint64 from, uint64 to, uint _amount) internal {\n        uint amount = _callPlugins(true, from, to, _amount);\n        if (from == to) {\n            return;\n        }\n        if (amount == 0) {\n            return;\n        }\n\n        Pledge storage pFrom = _findPledge(from);\n        Pledge storage pTo = _findPledge(to);\n\n        require(pFrom.amount >= amount);\n        pFrom.amount -= amount;\n        pTo.amount += amount;\n\n        Transfer(from, to, amount);\n        _callPlugins(false, from, to, amount);\n    }\n\n    /// @notice A getter to find the longest commitTime out of the owner and all\n    ///  the delegates for a specified pledge\n    /// @param p The Pledge being queried\n    /// @return The maximum commitTime out of the owner and all the delegates\n    function _maxCommitTime(Pledge p) internal view returns(uint64 commitTime) {\n        PledgeAdmin storage a = _findAdmin(p.owner);\n        commitTime = a.commitTime; // start with the owner's commitTime\n\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            a = _findAdmin(p.delegationChain[i]);\n\n            // If a delegate's commitTime is longer, make it the new commitTime\n            if (a.commitTime > commitTime) {\n                commitTime = a.commitTime;\n            }\n        }\n    }\n\n    /// @notice A getter to find the oldest pledge that hasn't been canceled\n    /// @param idPledge The starting place to lookup the pledges\n    /// @return The oldest idPledge that hasn't been canceled (DUH!)\n    function _getOldestPledgeNotCanceled(\n        uint64 idPledge\n    ) internal view returns(uint64)\n    {\n        if (idPledge == 0) {\n            return 0;\n        }\n\n        Pledge storage p = _findPledge(idPledge);\n        PledgeAdmin storage admin = _findAdmin(p.owner);\n        \n        if (admin.adminType == PledgeAdminType.Giver) {\n            return idPledge;\n        }\n\n        assert(admin.adminType == PledgeAdminType.Project);\n        if (!isProjectCanceled(p.owner)) {\n            return idPledge;\n        }\n\n        return _getOldestPledgeNotCanceled(p.oldPledge);\n    }\n\n    /// @notice `callPlugin` is used to trigger the general functions in the\n    ///  plugin for any actions needed before and after a transfer happens.\n    ///  Specifically what this does in relation to the plugin is something\n    ///  that largely depends on the functions of that plugin. This function\n    ///  is generally called in pairs, once before, and once after a transfer.\n    /// @param before This toggle determines whether the plugin call is occurring\n    ///  before or after a transfer.\n    /// @param adminId This should be the Id of the *trusted* individual\n    ///  who has control over this plugin.\n    /// @param fromPledge This is the Id from which value is being transfered.\n    /// @param toPledge This is the Id that value is being transfered to.\n    /// @param context The situation that is triggering the plugin. See plugin\n    ///  for a full description of contexts.\n    /// @param amount The amount of value that is being transfered.\n    function _callPlugin(\n        bool before,\n        uint64 adminId,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint64 context,\n        address token,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        uint newAmount;\n        allowedAmount = amount;\n        PledgeAdmin storage admin = _findAdmin(adminId);\n\n        // Checks admin has a plugin assigned and a non-zero amount is requested\n        if (address(admin.plugin) != 0 && allowedAmount > 0) {\n            // There are two separate functions called in the plugin.\n            // One is called before the transfer and one after\n            if (before) {\n                newAmount = admin.plugin.beforeTransfer(\n                    adminId,\n                    fromPledge,\n                    toPledge,\n                    context,\n                    token,\n                    amount\n                );\n                require(newAmount <= allowedAmount);\n                allowedAmount = newAmount;\n            } else {\n                admin.plugin.afterTransfer(\n                    adminId,\n                    fromPledge,\n                    toPledge,\n                    context,\n                    token,\n                    amount\n                );\n            }\n        }\n    }\n\n    /// @notice `callPluginsPledge` is used to apply plugin calls to\n    ///  the delegate chain and the intended project if there is one.\n    ///  It does so in either a transferring or receiving context based\n    ///  on the `p` and  `fromPledge` parameters.\n    /// @param before This toggle determines whether the plugin call is occuring\n    ///  before or after a transfer.\n    /// @param idPledge This is the id of the pledge on which this plugin\n    ///  is being called.\n    /// @param fromPledge This is the Id from which value is being transfered.\n    /// @param toPledge This is the Id that value is being transfered to.\n    /// @param amount The amount of value that is being transfered.\n    function _callPluginsPledge(\n        bool before,\n        uint64 idPledge,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        // Determine if callPlugin is being applied in a receiving\n        // or transferring context\n        uint64 offset = idPledge == fromPledge ? 0 : 256;\n        allowedAmount = amount;\n        Pledge storage p = _findPledge(idPledge);\n\n        // Always call the plugin on the owner\n        allowedAmount = _callPlugin(\n            before,\n            p.owner,\n            fromPledge,\n            toPledge,\n            offset,\n            p.token,\n            allowedAmount\n        );\n\n        // Apply call plugin to all delegates\n        for (uint64 i = 0; i < p.delegationChain.length; i++) {\n            allowedAmount = _callPlugin(\n                before,\n                p.delegationChain[i],\n                fromPledge,\n                toPledge,\n                offset + i + 1,\n                p.token,\n                allowedAmount\n            );\n        }\n\n        // If there is an intended project also call the plugin in\n        // either a transferring or receiving context based on offset\n        // on the intended project\n        if (p.intendedProject > 0) {\n            allowedAmount = _callPlugin(\n                before,\n                p.intendedProject,\n                fromPledge,\n                toPledge,\n                offset + 255,\n                p.token,\n                allowedAmount\n            );\n        }\n    }\n\n    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer\n    ///  context and once for the receiving context. The aggregated \n    ///  allowed amount is then returned.\n    /// @param before This toggle determines whether the plugin call is occurring\n    ///  before or after a transfer.\n    /// @param fromPledge This is the Id from which value is being transferred.\n    /// @param toPledge This is the Id that value is being transferred to.\n    /// @param amount The amount of value that is being transferred.\n    function _callPlugins(\n        bool before,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        allowedAmount = amount;\n\n        // Call the plugins in the transfer context\n        allowedAmount = _callPluginsPledge(\n            before,\n            fromPledge,\n            fromPledge,\n            toPledge,\n            allowedAmount\n        );\n\n        // Call the plugins in the receive context\n        allowedAmount = _callPluginsPledge(\n            before,\n            toPledge,\n            fromPledge,\n            toPledge,\n            allowedAmount\n        );\n    }\n\n/////////////\n// Test functions\n/////////////\n\n    /// @notice Basic helper function to return the current time\n    function _getTime() internal view returns (uint) {\n        return now;\n    }\n}\n"
    },
    "giveth-liquidpledging/contracts/LiquidPledging.sol": {
      "keccak256": "0xc98ae77346207a5fcdf07aac0f7f1ad366e517070a40ac56b859b8ca5a31ba3d",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/LiquidPledging.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n    Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledgingBase.sol\";\n\n/// @dev `LiquidPledging` allows for liquid pledging through the use of\n///  internal id structures and delegate chaining. All basic operations for\n///  handling liquid pledging are supplied as well as plugin features\n///  to allow for expanded functionality.\ncontract LiquidPledging is LiquidPledgingBase {\n\n    function LiquidPledging(address _escapeHatchDestination) EscapableApp(_escapeHatchDestination) public {\n    }\n\n    function addGiverAndDonate(uint64 idReceiver, address token, uint amount)\n        public\n    {\n        addGiverAndDonate(idReceiver, msg.sender, token, amount);\n    }\n\n    function addGiverAndDonate(uint64 idReceiver, address donorAddress, address token, uint amount)\n        public\n    {\n        require(donorAddress != 0);\n        // default to a 3 day (259200 seconds) commitTime\n        uint64 idGiver = addGiver(donorAddress, \"\", \"\", 259200, ILiquidPledgingPlugin(0));\n        donate(idGiver, idReceiver, token, amount);\n    }\n\n    /// @notice This is how value enters the system and how pledges are created;\n    ///  the ether is sent to the vault, an pledge for the Giver is created (or\n    ///  found), the amount of ETH donated in wei is added to the `amount` in\n    ///  the Giver's Pledge, and an LP transfer is done to the idReceiver for\n    ///  the full amount\n    /// @param idGiver The id of the Giver donating\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    function donate(uint64 idGiver, uint64 idReceiver, address token, uint amount)\n        public\n    {\n        require(idGiver > 0); // prevent burning donations. idReceiver is checked in _transfer\n        require(amount > 0);\n        require(token != 0x0);\n\n        PledgeAdmin storage sender = _findAdmin(idGiver);\n        require(sender.adminType == PledgeAdminType.Giver);\n\n        // TODO should this be done at the end of this function?\n        // what re-entrancy issues are there if this is done here?\n        // if done at the end of the function, will that affect plugins?\n        require(ERC20(token).transferFrom(msg.sender, address(vault), amount)); // transfer the token to the `vault`\n\n        uint64 idPledge = _findOrCreatePledge(\n            idGiver,\n            new uint64[](0), // Creates empty array for delegationChain\n            0,\n            0,\n            0,\n            token,\n            PledgeState.Pledged\n        );\n\n        Pledge storage pTo = _findPledge(idPledge);\n        pTo.amount += amount;\n\n        Transfer(0, idPledge, amount);\n\n        _transfer(idGiver, idPledge, amount, idReceiver);\n    }\n\n    /// @notice Transfers amounts between pledges for internal accounting\n    /// @param idSender Id of the Admin that is transferring the amount from\n    ///  Pledge to Pledge; this admin must have permissions to move the value\n    /// @param idPledge Id of the pledge that's moving the value\n    /// @param amount Quantity of ETH (in wei) that this pledge is transferring \n    ///  the authority to withdraw from the vault\n    /// @param idReceiver Destination of the `amount`, can be a Giver/Project sending\n    ///  to a Giver, a Delegate or a Project; a Delegate sending to another\n    ///  Delegate, or a Delegate pre-commiting it to a Project \n    function transfer( \n        uint64 idSender,\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) public\n    {\n        _checkAdminOwner(idSender);\n        _transfer(idSender, idPledge, amount, idReceiver);\n    }\n\n    /// @notice Authorizes a payment be made from the `vault` can be used by the\n    ///  Giver to veto a pre-committed donation from a Delegate to an\n    ///  intendedProject\n    /// @param idPledge Id of the pledge that is to be redeemed into ether\n    /// @param amount Quantity of ether (in wei) to be authorized\n    function withdraw(uint64 idPledge, uint amount) public {\n        idPledge = normalizePledge(idPledge); // Updates pledge info \n\n        Pledge storage p = _findPledge(idPledge);\n        require(p.pledgeState == PledgeState.Pledged);\n        _checkAdminOwner(p.owner);\n\n        uint64 idNewPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Paying\n        );\n\n        _doTransfer(idPledge, idNewPledge, amount);\n\n        PledgeAdmin storage owner = _findAdmin(p.owner);\n        vault.authorizePayment(bytes32(idNewPledge), owner.addr, p.token, amount);\n    }\n\n    /// @notice `onlyVault` Confirms a withdraw request changing the PledgeState\n    ///  from Paying to Paid\n    /// @param idPledge Id of the pledge that is to be withdrawn\n    /// @param amount Quantity of ether (in wei) to be withdrawn\n    function confirmPayment(uint64 idPledge, uint amount) public onlyVault {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.pledgeState == PledgeState.Paying);\n\n        uint64 idNewPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Paid\n        );\n\n        _doTransfer(idPledge, idNewPledge, amount);\n    }\n\n    /// @notice `onlyVault` Cancels a withdraw request, changing the PledgeState\n    ///  from Paying back to Pledged\n    /// @param idPledge Id of the pledge that's withdraw is to be canceled\n    /// @param amount Quantity of ether (in wei) to be canceled\n    function cancelPayment(uint64 idPledge, uint amount) public onlyVault {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.pledgeState == PledgeState.Paying);\n\n        // When a payment is canceled, never is assigned to a project.\n        uint64 idOldPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n\n        idOldPledge = normalizePledge(idOldPledge);\n\n        _doTransfer(idPledge, idOldPledge, amount);\n    }\n\n    /// @notice Changes the `project.canceled` flag to `true`; cannot be undone\n    /// @param idProject Id of the project that is to be canceled\n    function cancelProject(uint64 idProject) public {\n        PledgeAdmin storage project = _findAdmin(idProject);\n        _checkAdminOwner(idProject);\n        project.canceled = true;\n\n        CancelProject(idProject);\n    }\n\n    /// @notice Transfers `amount` in `idPledge` back to the `oldPledge` that\n    ///  that sent it there in the first place, a Ctrl-z \n    /// @param idPledge Id of the pledge that is to be canceled\n    /// @param amount Quantity of ether (in wei) to be transfered to the \n    ///  `oldPledge`\n    function cancelPledge(uint64 idPledge, uint amount) public {\n        idPledge = normalizePledge(idPledge);\n\n        Pledge storage p = _findPledge(idPledge);\n        require(p.oldPledge != 0);\n        require(p.pledgeState == PledgeState.Pledged);\n        _checkAdminOwner(p.owner);\n\n        uint64 oldPledge = _getOldestPledgeNotCanceled(p.oldPledge);\n        _doTransfer(idPledge, oldPledge, amount);\n    }\n\n\n////////\n// Multi pledge methods\n////////\n\n    // @dev This set of functions makes moving a lot of pledges around much more\n    // efficient (saves gas) than calling these functions in series\n    \n    \n    /// @dev Bitmask used for dividing pledge amounts in Multi pledge methods\n    uint constant D64 = 0x10000000000000000;\n\n    /// @notice Transfers multiple amounts within multiple Pledges in an\n    ///  efficient single call \n    /// @param idSender Id of the Admin that is transferring the amounts from\n    ///  all the Pledges; this admin must have permissions to move the value\n    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with \n    ///  which the amounts are associated; these are extrapolated using the D64\n    ///  bitmask\n    /// @param idReceiver Destination of the `pledesAmounts`, can be a Giver or \n    ///  Project sending to a Giver, a Delegate or a Project; a Delegate sending\n    ///  to another Delegate, or a Delegate pre-commiting it to a Project \n    function mTransfer(\n        uint64 idSender,\n        uint[] pledgesAmounts,\n        uint64 idReceiver\n    ) public \n    {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            transfer(idSender, idPledge, amount, idReceiver);\n        }\n    }\n\n    /// @notice Authorizes multiple amounts within multiple Pledges to be\n    ///  withdrawn from the `vault` in an efficient single call \n    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with \n    ///  which the amounts are associated; these are extrapolated using the D64\n    ///  bitmask\n    function mWithdraw(uint[] pledgesAmounts) public {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            withdraw(idPledge, amount);\n        }\n    }\n\n    /// @notice `mConfirmPayment` allows for multiple pledges to be confirmed\n    ///  efficiently\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\n    ///  using the D64 bitmask\n    function mConfirmPayment(uint[] pledgesAmounts) public {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            confirmPayment(idPledge, amount);\n        }\n    }\n\n    /// @notice `mCancelPayment` allows for multiple pledges to be canceled\n    ///  efficiently\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\n    ///  using the D64 bitmask\n    function mCancelPayment(uint[] pledgesAmounts) public {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            cancelPayment(idPledge, amount);\n        }\n    }\n\n    /// @notice `mNormalizePledge` allows for multiple pledges to be\n    ///  normalized efficiently\n    /// @param pledges An array of pledge IDs\n    function mNormalizePledge(uint64[] pledges) public {\n        for (uint i = 0; i < pledges.length; i++ ) {\n            normalizePledge(pledges[i]);\n        }\n    }\n}\n"
    },
    "minimetoken/contracts/Controlled.sol": {
      "keccak256": "0x770798704985a4588762ea932b913bc1df01b4625ab86c5a7278883bbde44b78",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/minimetoken/contracts/Controlled.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\ncontract Controlled {\n    /// @notice The address of the controller is the only address that can call\n    ///  a function with this modifier\n    modifier onlyController { require(msg.sender == controller); _; }\n\n    address public controller;\n\n    function Controlled() public { controller = msg.sender;}\n\n    /// @notice Changes the controller of the contract\n    /// @param _newController The new controller of the contract\n    function changeController(address _newController) public onlyController {\n        controller = _newController;\n    }\n}\n"
    },
    "minimetoken/contracts/TokenController.sol": {
      "keccak256": "0xf8bf7de20c0412ab90ec43c1432508a8316e17bd246adffa737e0d779413ff5e",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/minimetoken/contracts/TokenController.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/// @dev The token controller contract must implement these functions\ncontract TokenController {\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n    /// @param _owner The address that sent the ether to create tokens\n    /// @return True if the ether is accepted, false if it throws\n    function proxyPayment(address _owner) public payable returns(bool);\n\n    /// @notice Notifies the controller about a token transfer allowing the\n    ///  controller to react if desired\n    /// @param _from The origin of the transfer\n    /// @param _to The destination of the transfer\n    /// @param _amount The amount of the transfer\n    /// @return False if the controller does not authorize the transfer\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n\n    /// @notice Notifies the controller about an approval allowing the\n    ///  controller to react if desired\n    /// @param _owner The address that calls `approve()`\n    /// @param _spender The spender in the `approve()` call\n    /// @param _amount The amount in the `approve()` call\n    /// @return False if the controller does not authorize the approval\n    function onApprove(address _owner, address _spender, uint _amount) public\n        returns(bool);\n}\n"
    },
    "minimetoken/contracts/MiniMeToken.sol": {
      "keccak256": "0x3dba5ff0dd1de9ebff6cd48898e78f7ce7c9996d345c702dca6a3a7d69750ed4",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/minimetoken/contracts/MiniMeToken.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2016, Jordi Baylina\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/// @title MiniMeToken Contract\n/// @author Jordi Baylina\n/// @dev This token contract's goal is to make it easy for anyone to clone this\n///  token using the token distribution at a given block, this will allow DAO's\n///  and DApps to upgrade their features in a decentralized manner without\n///  affecting the original token\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\n\nimport \"./Controlled.sol\";\nimport \"./TokenController.sol\";\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\n\n/// @dev The actual token contract, the default controller is the msg.sender\n///  that deploys the contract, so usually this token will be deployed by a\n///  token controller contract, which Giveth will call a \"Campaign\"\ncontract MiniMeToken is Controlled {\n\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = 'MMT_0.2'; //An arbitrary versioning scheme\n\n\n    /// @dev `Checkpoint` is the structure that attaches a block number to a\n    ///  given value, the block number attached is the one that last changed the\n    ///  value\n    struct  Checkpoint {\n\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    MiniMeToken public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n    // The factory used to create new clone tokens\n    MiniMeTokenFactory public tokenFactory;\n\n////////////////\n// Constructor\n////////////////\n\n    /// @notice Constructor to create a MiniMeToken\n    /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\n    ///  will create the Clone token contracts, the token factory needs to be\n    ///  deployed first\n    /// @param _parentToken Address of the parent token, set to 0x0 if it is a\n    ///  new token\n    /// @param _parentSnapShotBlock Block of the parent token that will\n    ///  determine the initial distribution of the clone token, set to 0 if it\n    ///  is a new token\n    /// @param _tokenName Name of the new token\n    /// @param _decimalUnits Number of decimals of the new token\n    /// @param _tokenSymbol Token Symbol for the new token\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\n    function MiniMeToken(\n        address _tokenFactory,\n        address _parentToken,\n        uint _parentSnapShotBlock,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol,\n        bool _transfersEnabled\n    ) public {\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = MiniMeToken(_parentToken);\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n///////////////////\n// ERC20 Methods\n///////////////////\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    ///  is approved by `_from`\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return True if the transfer was successful\n    function transferFrom(address _from, address _to, uint256 _amount\n    ) public returns (bool success) {\n\n        // The controller of this contract can move tokens around at will,\n        //  this is important to recognize! Confirm that you trust the\n        //  controller of this contract, which in most situations should be\n        //  another open source smart contract or 0x0\n        if (msg.sender != controller) {\n            require(transfersEnabled);\n\n            // The standard ERC 20 transferFrom functionality\n            if (allowed[_from][msg.sender] < _amount) return false;\n            allowed[_from][msg.sender] -= _amount;\n        }\n        return doTransfer(_from, _to, _amount);\n    }\n\n    /// @dev This is the actual transfer function in the token contract, it can\n    ///  only be called by other functions in this contract.\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return True if the transfer was successful\n    function doTransfer(address _from, address _to, uint _amount\n    ) internal returns(bool) {\n\n           if (_amount == 0) {\n               return true;\n           }\n\n           require(parentSnapShotBlock < block.number);\n\n           // Do not allow transfer to 0x0 or the token contract itself\n           require((_to != 0) && (_to != address(this)));\n\n           // If the amount being transfered is more than the balance of the\n           //  account the transfer returns false\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\n           if (previousBalanceFrom < _amount) {\n               return false;\n           }\n\n           // Alerts the token controller of the transfer\n           if (isContract(controller)) {\n               require(TokenController(controller).onTransfer(_from, _to, _amount));\n           }\n\n           // First update the balance array with the new value for the address\n           //  sending the tokens\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n\n           // Then update the balance array with the new value for the address\n           //  receiving the tokens\n           var previousBalanceTo = balanceOfAt(_to, block.number);\n           require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n\n           // An event to make the transfer easy to find on the blockchain\n           Transfer(_from, _to, _amount);\n\n           return true;\n    }\n\n    /// @param _owner The address that's balance is being requested\n    /// @return The balance of `_owner` at the current block\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    ///  its behalf. This is a modified version of the ERC20 approve function\n    ///  to be a little bit safer\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return True if the approval was successful\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        // Alerts the token controller of the approve function call\n        if (isContract(controller)) {\n            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n        }\n\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /// @dev This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender\n    ) public constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n    ///  its behalf, and then a function is triggered in the contract that is\n    ///  being approved, `_spender`. This allows users to use their tokens to\n    ///  interact with contracts in one function call instead of two\n    /// @param _spender The address of the contract able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return True if the function call was successful\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n    ) public returns (bool success) {\n        require(approve(_spender, _amount));\n\n        ApproveAndCallFallBack(_spender).receiveApproval(\n            msg.sender,\n            _amount,\n            this,\n            _extraData\n        );\n\n        return true;\n    }\n\n    /// @dev This function makes it easy to get the total number of tokens\n    /// @return The total number of tokens\n    function totalSupply() public constant returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n////////////////\n// Query balance and totalSupply in History\n////////////////\n\n    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n    /// @param _owner The address from which the balance will be retrieved\n    /// @param _blockNumber The block number when the balance is queried\n    /// @return The balance at `_blockNumber`\n    function balanceOfAt(address _owner, uint _blockNumber) public constant\n        returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0)\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != 0) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    /// @notice Total amount of tokens at a specific `_blockNumber`.\n    /// @param _blockNumber The block number when the totalSupply is queried\n    /// @return The total amount of tokens at `_blockNumber`\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0)\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != 0) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n////////////////\n// Clone Token Method\n////////////////\n\n    /// @notice Creates a new clone token with the initial distribution being\n    ///  this token at `_snapshotBlock`\n    /// @param _cloneTokenName Name of the clone token\n    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\n    /// @param _cloneTokenSymbol Symbol of the clone token\n    /// @param _snapshotBlock Block when the distribution of the parent token is\n    ///  copied to set the initial distribution of the new clone token;\n    ///  if the block is zero than the actual block, the current block is used\n    /// @param _transfersEnabled True if transfers are allowed in the clone\n    /// @return The address of the new MiniMeToken Contract\n    function createCloneToken(\n        string _cloneTokenName,\n        uint8 _cloneDecimalUnits,\n        string _cloneTokenSymbol,\n        uint _snapshotBlock,\n        bool _transfersEnabled\n        ) public returns(address) {\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\n            this,\n            _snapshotBlock,\n            _cloneTokenName,\n            _cloneDecimalUnits,\n            _cloneTokenSymbol,\n            _transfersEnabled\n            );\n\n        cloneToken.changeController(msg.sender);\n\n        // An event to make the token easy to find on the blockchain\n        NewCloneToken(address(cloneToken), _snapshotBlock);\n        return address(cloneToken);\n    }\n\n////////////////\n// Generate and destroy tokens\n////////////////\n\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\n    /// @param _owner The address that will be assigned the new tokens\n    /// @param _amount The quantity of tokens generated\n    /// @return True if the tokens are generated correctly\n    function generateTokens(address _owner, uint _amount\n    ) public onlyController returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        Transfer(0, _owner, _amount);\n        return true;\n    }\n\n\n    /// @notice Burns `_amount` tokens from `_owner`\n    /// @param _owner The address that will lose the tokens\n    /// @param _amount The quantity of tokens to burn\n    /// @return True if the tokens are burned correctly\n    function destroyTokens(address _owner, uint _amount\n    ) onlyController public returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        Transfer(_owner, 0, _amount);\n        return true;\n    }\n\n////////////////\n// Enable tokens transfers\n////////////////\n\n\n    /// @notice Enables token holders to transfer their tokens freely if true\n    /// @param _transfersEnabled True if transfers are allowed in the clone\n    function enableTransfers(bool _transfersEnabled) public onlyController {\n        transfersEnabled = _transfersEnabled;\n    }\n\n////////////////\n// Internal helper functions to query and set a value in a snapshot array\n////////////////\n\n    /// @dev `getValueAt` retrieves the number of tokens at a given block number\n    /// @param checkpoints The history of values being queried\n    /// @param _block The block number to retrieve the value at\n    /// @return The number of tokens being queried\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\n    ) constant internal returns (uint) {\n        if (checkpoints.length == 0) return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock) return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1)/ 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    /// @dev `updateValueAtNow` used to update the `balances` map and the\n    ///  `totalSupplyHistory`\n    /// @param checkpoints The history of data being updated\n    /// @param _value The new number of tokens\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n    ) internal  {\n        if ((checkpoints.length == 0)\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n               newCheckPoint.fromBlock =  uint128(block.number);\n               newCheckPoint.value = uint128(_value);\n           } else {\n               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n               oldCheckPoint.value = uint128(_value);\n           }\n    }\n\n    /// @dev Internal function to determine if an address is a contract\n    /// @param _addr The address being queried\n    /// @return True if `_addr` is a contract\n    function isContract(address _addr) constant internal returns(bool) {\n        uint size;\n        if (_addr == 0) return false;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return size>0;\n    }\n\n    /// @dev Helper function to return a min betwen the two uints\n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    /// @notice The fallback function: If the contract's controller has not been\n    ///  set to 0, then the `proxyPayment` method is called which relays the\n    ///  ether and creates tokens as described in the token controller contract\n    function () public payable {\n        require(isContract(controller));\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n    }\n\n//////////\n// Safety Methods\n//////////\n\n    /// @notice This method can be used by the controller to extract mistakenly\n    ///  sent tokens to this contract.\n    /// @param _token The address of the token contract that you want to recover\n    ///  set to 0 in case you want to extract ether.\n    function claimTokens(address _token) public onlyController {\n        if (_token == 0x0) {\n            controller.transfer(this.balance);\n            return;\n        }\n\n        MiniMeToken token = MiniMeToken(_token);\n        uint balance = token.balanceOf(this);\n        token.transfer(controller, balance);\n        ClaimedTokens(_token, controller, balance);\n    }\n\n////////////////\n// Events\n////////////////\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n}\n\n\n////////////////\n// MiniMeTokenFactory\n////////////////\n\n/// @dev This contract is used to generate clone contracts from a contract.\n///  In solidity this is the way to create a contract from a contract of the\n///  same class\ncontract MiniMeTokenFactory {\n\n    /// @notice Update the DApp by creating a new token with new functionalities\n    ///  the msg.sender becomes the controller of this clone token\n    /// @param _parentToken Address of the token being cloned\n    /// @param _snapshotBlock Block of the parent token that will\n    ///  determine the initial distribution of the clone token\n    /// @param _tokenName Name of the new token\n    /// @param _decimalUnits Number of decimals of the new token\n    /// @param _tokenSymbol Token Symbol for the new token\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\n    /// @return The address of the new token contract\n    function createCloneToken(\n        address _parentToken,\n        uint _snapshotBlock,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol,\n        bool _transfersEnabled\n    ) public returns (MiniMeToken) {\n        MiniMeToken newToken = new MiniMeToken(\n            this,\n            _parentToken,\n            _snapshotBlock,\n            _tokenName,\n            _decimalUnits,\n            _tokenSymbol,\n            _transfersEnabled\n            );\n\n        newToken.changeController(msg.sender);\n        return newToken;\n    }\n}\n"
    },
    "./contracts/LPPDac.sol": {
      "keccak256": "0x8340cd001313b84f1e1ead43d27d9aa9dfebd5a05348e4d6a833fd9e55fb836c",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/contracts/LPPDac.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, RJ Ewing <perissology@protonmail.com>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"giveth-liquidpledging/contracts/LiquidPledging.sol\";\nimport \"giveth-liquidpledging/contracts/EscapableApp.sol\";\nimport \"minimetoken/contracts/MiniMeToken.sol\";\n\ncontract LPPDac is EscapableApp, TokenController {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    uint constant FROM_FIRST_DELEGATE = 1;\n    uint constant TO_FIRST_DELEGATE = 257;\n\n    LiquidPledging public liquidPledging;\n    MiniMeToken public dacToken;\n    uint64 public idDelegate;\n\n    event GenerateTokens(address indexed liquidPledging, address addr, uint amount);\n    event DestroyTokens(address indexed liquidPledging, address addr, uint amount);\n\n    //== constructor\n\n    function LPPDac(address _escapeHatchDestination) EscapableApp(_escapeHatchDestination) public {}\n\n    function initialize(address _escapeHatchDestination) onlyInit public {\n        require(false); // overload the EscapableApp\n        _escapeHatchDestination;\n    }\n\n    function initialize(\n        address _liquidPledging,\n        address _token,\n        string name,\n        string url,\n        uint64 commitTime,\n        address _escapeHatchDestination\n    ) onlyInit external\n    {\n        super.initialize(_escapeHatchDestination);\n        require(_liquidPledging != 0);\n        require(_token != 0);\n\n        liquidPledging = LiquidPledging(_liquidPledging);\n\n        idDelegate = liquidPledging.addDelegate(\n            name,\n            url,\n            commitTime,\n            ILiquidPledgingPlugin(this)\n        );\n\n        dacToken = MiniMeToken(_token);\n    }\n\n    //== external\n\n    /// @dev this is called by liquidPledging before every transfer to and from\n    ///      a pledgeAdmin that has this contract as its plugin\n    /// @dev see ILiquidPledgingPlugin interface for details about context param\n    function beforeTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount\n    ) external returns (uint maxAllowed)\n    {\n        require(msg.sender == address(liquidPledging));\n        return amount;\n    }\n\n    /// @dev this is called by liquidPledging after every transfer to and from\n    ///      a pledgeAdmin that has this contract as its plugin\n    /// @dev see ILiquidPledgingPlugin interface for details about context param\n    function afterTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount\n    ) external\n    {\n        require(msg.sender == address(liquidPledging));\n        var (, toOwner, , toIntendedProject, , , , toPledgeState ) = liquidPledging.getPledge(pledgeTo);\n        var (, fromOwner, , , , , , ) = liquidPledging.getPledge(pledgeFrom);\n        var (toAdminType, toAddr, , , , , , ) = liquidPledging.getPledgeAdmin(toOwner);\n\n        // only issue dacTokens when pledge is committed to a project and a dac is the first delegate\n        if (context == FROM_FIRST_DELEGATE &&\n                toIntendedProject == 0 &&\n                toAdminType == LiquidPledgingStorage.PledgeAdminType.Project &&\n                toOwner != fromOwner &&\n                toPledgeState == LiquidPledgingStorage.PledgeState.Pledged)\n        {\n            var (, fromAddr , , , , , , ) = liquidPledging.getPledgeAdmin(fromOwner);\n\n            dacToken.generateTokens(fromAddr, amount);\n            GenerateTokens(address(liquidPledging), fromAddr, amount);\n        }\n\n        // if a committed project is canceled and the pledge is rolling back to a\n        // dac, we need to burn the tokens that were generated\n        if ( (context == TO_FIRST_DELEGATE) &&\n            liquidPledging.isProjectCanceled(fromOwner)) {\n\n            if (dacToken.balanceOf(toAddr) >= amount) {\n                dacToken.destroyTokens(toAddr, amount);\n                DestroyTokens(address(liquidPledging), toAddr, amount);\n            }\n\n        }\n    }\n\n    function transfer(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) external authP(ADMIN_ROLE, arr(uint(idPledge), amount, uint(idReceiver)))\n    {\n        liquidPledging.transfer(\n            idDelegate,\n            idPledge,\n            amount,\n            idReceiver\n        );\n    }\n\n    uint constant D64 = 0x10000000000000000;\n\n    function mTransfer(\n        uint[] pledgesAmounts,\n        uint64 idReceiver\n    ) external\n    {\n        // TODO is there a more efficient way to do this? we can't pass array into canPerform function\n        // this has ~ 15k gas overhead / pledge vs a single authP\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            require(canPerform(msg.sender, ADMIN_ROLE, arr(idPledge, amount, uint(idReceiver))));\n        }\n\n        liquidPledging.mTransfer(\n            idDelegate,\n            pledgesAmounts,\n            idReceiver\n        );\n    }\n\n    function update(\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) public auth(ADMIN_ROLE)\n    {\n        liquidPledging.updateDelegate(\n            idDelegate,\n            address(this),\n            newName,\n            newUrl,\n            newCommitTime\n        );\n    }\n\n    ////////////////\n    // TokenController\n    ////////////////\n\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n    /// @param _owner The address that sent the ether to create tokens\n    /// @return True if the ether is accepted, false if it throws\n    function proxyPayment(address _owner) public payable returns(bool) {\n        return false;\n    }\n\n    /// @notice Notifies the controller about a token transfer allowing the\n    ///  controller to react if desired\n    /// @param _from The origin of the transfer\n    /// @param _to The destination of the transfer\n    /// @param _amount The amount of the transfer\n    /// @return False if the controller does not authorize the transfer\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool) {\n        return false;\n    }\n\n    /// @notice Notifies the controller about an approval allowing the\n    ///  controller to react if desired\n    /// @param _owner The address that calls `approve()`\n    /// @param _spender The spender in the `approve()` call\n    /// @param _amount The amount in the `approve()` call\n    /// @return False if the controller does not authorize the approval\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool) {\n        return false;\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/IAppProxy.sol": {
      "keccak256": "0x4d5f398f887030d6d0b5045e0424b59d58abd718143289afcaf3e160d6c91736",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/apps/IAppProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\ninterface IAppProxy {\n    function isUpgradeable() public pure returns (bool);\n    function getCode() public view returns (address);\n}\n"
    },
    "@aragon/os/contracts/common/DelegateProxy.sol": {
      "keccak256": "0x81bab220700a9a5def3ac54278ccec046be0b1c333dba9567f7175e358414d87",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/common/DelegateProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract DelegateProxy {\n    /**\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n    * @param _dst Destination address to perform the delegatecall\n    * @param _calldata Calldata for the delegatecall\n    */\n    function delegatedFwd(address _dst, bytes _calldata) internal {\n        require(isContract(_dst));\n        assembly {\n            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            let size := returndatasize\n\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n\n    function isContract(address _target) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"
    },
    "@aragon/os/contracts/kernel/KernelStorage.sol": {
      "keccak256": "0x5eeaeb6e75a435278d5a2d74dab865bd9c2a88fba296db5b8669769d6a60573e",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/kernel/KernelStorage.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract KernelConstants {\n    bytes32 constant public CORE_NAMESPACE = keccak256(\"core\");\n    bytes32 constant public APP_BASES_NAMESPACE = keccak256(\"base\");\n    bytes32 constant public APP_ADDR_NAMESPACE = keccak256(\"app\");\n\n    bytes32 constant public KERNEL_APP_ID = keccak256(\"kernel.aragonpm.eth\");\n    bytes32 constant public KERNEL_APP = keccak256(CORE_NAMESPACE, KERNEL_APP_ID);\n\n    bytes32 constant public ACL_APP_ID = keccak256(\"acl.aragonpm.eth\");\n    bytes32 constant public ACL_APP = keccak256(APP_ADDR_NAMESPACE, ACL_APP_ID);\n}\n\n\ncontract KernelStorage is KernelConstants {\n    mapping (bytes32 => address) public apps;\n}\n"
    },
    "@aragon/os/contracts/apps/AppProxyBase.sol": {
      "keccak256": "0x907218cac02c5f7a10873eb30fb1ffaecdd93527a0ff7e2f0305590bf585d06b",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/apps/AppProxyBase.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./IAppProxy.sol\";\nimport \"./AppStorage.sol\";\nimport \"../common/DelegateProxy.sol\";\nimport \"../kernel/KernelStorage.sol\";\n\n\ncontract AppProxyBase is IAppProxy, AppStorage, DelegateProxy, KernelConstants {\n    /**\n    * @dev Initialize AppProxy\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyBase(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n        kernel = _kernel;\n        appId = _appId;\n\n        // Implicit check that kernel is actually a Kernel\n        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\n        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n        // it.\n        address appCode = getAppBase(appId);\n\n        // If initialize payload is provided, it will be executed\n        if (_initializePayload.length > 0) {\n            require(isContract(appCode));\n            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n            // returns ending execution context and halts contract deployment\n            require(appCode.delegatecall(_initializePayload));\n        }\n    }\n\n    function getAppBase(bytes32 _appId) internal view returns (address) {\n        return kernel.getApp(keccak256(APP_BASES_NAMESPACE, _appId));\n    }\n\n    function () payable public {\n        address target = getCode();\n        require(target != 0); // if app code hasn't been set yet, don't call\n        delegatedFwd(target, msg.data);\n    }\n}"
    },
    "@aragon/os/contracts/apps/AppProxyUpgradeable.sol": {
      "keccak256": "0x4613af6e313048b7de649d54630276fb18154dac5674f057109f0e0591f11cb2",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/apps/AppProxyUpgradeable.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyUpgradeable is AppProxyBase {\n    address public pinnedCode;\n\n    /**\n    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyUpgradeable(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n\n    }\n\n    function getCode() public view returns (address) {\n        return getAppBase(appId);\n    }\n\n    function isUpgradeable() public pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/AppProxyPinned.sol": {
      "keccak256": "0xfe66e88413adc4d60ae53352046bd23ebd0aeb3120599d445df19caa8b095c26",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/apps/AppProxyPinned.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyPinned is AppProxyBase {\n    /**\n    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n        pinnedCode = getAppBase(appId);\n        require(pinnedCode != address(0));\n    }\n\n    function getCode() public view returns (address) {\n        return pinnedCode;\n    }\n\n    function isUpgradeable() public pure returns (bool) {\n        return false;\n    }\n\n    function () payable public {\n        delegatedFwd(getCode(), msg.data);\n    }\n}"
    },
    "@aragon/os/contracts/factory/AppProxyFactory.sol": {
      "keccak256": "0xa5314f57f93d8e633724bd9f94ad43f127c5b5466dcd0ef32fe0f78d5d431592",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/factory/AppProxyFactory.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AppProxyUpgradeable.sol\";\nimport \"../apps/AppProxyPinned.sol\";\n\n\ncontract AppProxyFactory {\n    event NewAppProxy(address proxy);\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n        return newAppProxy(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy));\n        return proxy;\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy));\n        return proxy;\n    }\n}\n"
    },
    "@aragon/os/contracts/kernel/Kernel.sol": {
      "keccak256": "0xb92133309dd893097c4cf180c998912c86229c047f6738f9121def14897ca294",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/kernel/Kernel.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./IKernel.sol\";\nimport \"./KernelStorage.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../apps/IAppProxy.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../factory/AppProxyFactory.sol\";\n\n\ncontract Kernel is IKernel, KernelStorage, Initializable, AppProxyFactory, ACLSyntaxSugar {\n    bytes32 constant public APP_MANAGER_ROLE = keccak256(\"APP_MANAGER_ROLE\");\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes a kernel instance along with its ACL and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _baseAcl Address of base ACL app\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _baseAcl, address _permissionsCreator) onlyInit public {\n        initialized();\n\n        IACL acl = IACL(newAppProxy(this, ACL_APP_ID));\n\n        _setApp(APP_BASES_NAMESPACE, ACL_APP_ID, _baseAcl);\n        _setApp(APP_ADDR_NAMESPACE, ACL_APP_ID, acl);\n\n        acl.initialize(_permissionsCreator);\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel and set its base\n    *      implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (IAppProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxy(this, _name);\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel and set\n    *      its base implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (IAppProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxyPinned(this, _name);\n    }\n\n    /**\n    * @dev Set the resolving address of an app instance or base implementation\n    * @param _namespace App namespace to use\n    * @param _name Name of the app\n    * @param _app Address of the app\n    * @return ID of app\n    */\n    function setApp(bytes32 _namespace, bytes32 _name, address _app) auth(APP_MANAGER_ROLE, arr(_namespace, _name)) kernelIntegrity public returns (bytes32 id) {\n        return _setApp(_namespace, _name, _app);\n    }\n\n    /**\n    * @dev Get the address of an app instance or base implementation\n    * @param _id App identifier\n    * @return Address of the app\n    */\n    function getApp(bytes32 _id) public view returns (address) {\n        return apps[_id];\n    }\n\n    /**\n    * @dev Get the installed ACL app\n    * @return ACL app\n    */\n    function acl() public view returns (IACL) {\n        return IACL(getApp(ACL_APP));\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission status\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _what Identifier for a group of actions in app\n    * @param _how Extra data for ACL auth\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\n        return acl().hasPermission(_who, _where, _what, _how);\n    }\n\n    function _setApp(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        id = keccak256(_namespace, _name);\n        apps[id] = _app;\n        SetApp(_namespace, _name, id, _app);\n    }\n\n    function _setAppIfNew(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        id = keccak256(_namespace, _name);\n\n        if (_app != address(0)) {\n            address app = getApp(id);\n            if (app != address(0)) {\n                require(app == _app);\n            } else {\n                apps[id] = _app;\n                SetApp(_namespace, _name, id, _app);\n            }\n        }\n    }\n\n    modifier auth(bytes32 _role, uint256[] memory params) {\n        bytes memory how;\n        uint256 byteLength = params.length * 32;\n        assembly {\n            how := params // forced casting\n            mstore(how, byteLength)\n        }\n        // Params is invalid from this point fwd\n        require(hasPermission(msg.sender, address(this), _role, how));\n        _;\n    }\n\n    modifier kernelIntegrity {\n        _; // After execution check integrity\n        address kernel = getApp(KERNEL_APP);\n        uint256 size;\n        assembly { size := extcodesize(kernel) }\n        require(size > 0);\n    }\n}\n"
    },
    "@aragon/os/contracts/acl/ACL.sol": {
      "keccak256": "0x6a0035dd4ff7cfacae9225f730c5ff5fe4547e4316e90129d084a07c0ba1d05c",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/@aragon/os/contracts/acl/ACL.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AragonApp.sol\";\nimport \"./ACLSyntaxSugar.sol\";\nimport \"./IACL.sol\";\n\n\ninterface ACLOracle {\n    function canPerform(address who, address where, bytes32 what) public view returns (bool);\n}\n\n\ncontract ACL is IACL, AragonApp, ACLHelpers {\n    bytes32 constant public CREATE_PERMISSIONS_ROLE = keccak256(\"CREATE_PERMISSIONS_ROLE\");\n\n    // whether a certain entity has a permission\n    mapping (bytes32 => bytes32) permissions; // 0 for no permission, or parameters id\n    mapping (bytes32 => Param[]) public permissionParams;\n\n    // who is the manager of a permission\n    mapping (bytes32 => address) permissionManager;\n\n    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, NOT, AND, OR, XOR, IF_ELSE, RET } // op types\n\n    struct Param {\n        uint8 id;\n        uint8 op;\n        uint240 value; // even though value is an uint240 it can store addresses\n        // in the case of 32 byte hashes losing 2 bytes precision isn't a huge deal\n        // op and id take less than 1 byte each so it can be kept in 1 sstore\n    }\n\n    uint8 constant BLOCK_NUMBER_PARAM_ID = 200;\n    uint8 constant TIMESTAMP_PARAM_ID    = 201;\n    uint8 constant SENDER_PARAM_ID       = 202;\n    uint8 constant ORACLE_PARAM_ID       = 203;\n    uint8 constant LOGIC_OP_PARAM_ID     = 204;\n    uint8 constant PARAM_VALUE_PARAM_ID  = 205;\n    // TODO: Add execution times param type?\n\n    bytes32 constant public EMPTY_PARAM_HASH = keccak256(uint256(0));\n    address constant ANY_ENTITY = address(-1);\n\n    modifier onlyPermissionManager(address _app, bytes32 _role) {\n        require(msg.sender == getPermissionManager(_app, _role));\n        _;\n    }\n\n    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\n    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes an ACL instance and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _permissionsCreator) onlyInit public {\n        initialized();\n        require(msg.sender == address(kernel));\n\n        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\n    }\n\n    /**\n    * @dev Creates a permission that wasn't previously set. Access is limited by the ACL.\n    *      If a created permission is removed it is possible to reset it with createPermission.\n    * @notice Create a new permission granting `_entity` the ability to perform actions of role `_role` on `_app` (setting `_manager` as the permission manager)\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\n    */\n    function createPermission(address _entity, address _app, bytes32 _role, address _manager) external {\n        require(hasPermission(msg.sender, address(this), CREATE_PERMISSIONS_ROLE));\n\n        _createPermission(_entity, _app, _role, _manager);\n    }\n\n    /**\n    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    */\n    function grantPermission(address _entity, address _app, bytes32 _role)\n        external\n    {\n        grantPermissionP(_entity, _app, _role, new uint256[](0));\n    }\n\n    /**\n    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _params Permission parameters\n    */\n    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\n        onlyPermissionManager(_app, _role)\n        public\n    {\n        require(!hasPermission(_entity, _app, _role));\n\n        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\n        _setPermission(_entity, _app, _role, paramsHash);\n    }\n\n    /**\n    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\n    * @notice Revokes `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity to revoke access from\n    * @param _app Address of the app in which the role will be revoked\n    * @param _role Identifier for the group of actions in app being revoked\n    */\n    function revokePermission(address _entity, address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        require(hasPermission(_entity, _app, _role));\n\n        _setPermission(_entity, _app, _role, bytes32(0));\n    }\n\n    /**\n    * @notice Sets `_newManager` as the manager of the permission `_role` in `_app`\n    * @param _newManager Address for the new manager\n    * @param _app Address of the app in which the permission management is being transferred\n    * @param _role Identifier for the group of actions being transferred\n    */\n    function setPermissionManager(address _newManager, address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        _setPermissionManager(_newManager, _app, _role);\n    }\n\n    /**\n    * @dev Get manager for permission\n    * @param _app Address of the app\n    * @param _role Identifier for a group of actions in app\n    * @return address of the manager for the permission\n    */\n    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\n        return permissionManager[roleHash(_app, _role)];\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission statu\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _where Identifier for a group of actions in app\n    * @param _how Permission parameters\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\n        uint256[] memory how;\n        uint256 intsLength = _how.length / 32;\n        assembly {\n            how := _how // forced casting\n            mstore(how, intsLength)\n        }\n        // _how is invalid from this point fwd\n        return hasPermission(_who, _where, _what, how);\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\n        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\n        if (whoParams != bytes32(0) && evalParams(whoParams, _who, _where, _what, _how)) {\n            return true;\n        }\n\n        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\n        if (anyParams != bytes32(0) && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\n        uint256[] memory empty = new uint256[](0);\n        return hasPermission(_who, _where, _what, empty);\n    }\n\n    /**\n    * @dev Internal createPermission for access inside the kernel (on instantiation)\n    */\n    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\n        // only allow permission creation (or re-creation) when there is no manager\n        require(getPermissionManager(_app, _role) == address(0));\n\n        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\n        _setPermissionManager(_manager, _app, _role);\n    }\n\n    /**\n    * @dev Internal function called to actually save the permission\n    */\n    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\n        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\n\n        SetPermission(_entity, _app, _role, _paramsHash != bytes32(0));\n    }\n\n    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\n        bytes32 paramHash = keccak256(_encodedParams);\n        Param[] storage params = permissionParams[paramHash];\n\n        if (params.length == 0) { // params not saved before\n            for (uint256 i = 0; i < _encodedParams.length; i++) {\n                uint256 encodedParam = _encodedParams[i];\n                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\n                params.push(param);\n            }\n        }\n\n        return paramHash;\n    }\n\n    function evalParams(\n        bytes32 _paramsHash,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) internal view returns (bool)\n    {\n        if (_paramsHash == EMPTY_PARAM_HASH) {\n            return true;\n        }\n\n        return evalParam(_paramsHash, 0, _who, _where, _what, _how);\n    }\n\n    function evalParam(\n        bytes32 _paramsHash,\n        uint32 _paramId,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) internal view returns (bool)\n    {\n        if (_paramId >= permissionParams[_paramsHash].length) {\n            return false; // out of bounds\n        }\n\n        Param memory param = permissionParams[_paramsHash][_paramId];\n\n        if (param.id == LOGIC_OP_PARAM_ID) {\n            return evalLogic(param, _paramsHash, _who, _where, _what, _how);\n        }\n\n        uint256 value;\n        uint256 comparedTo = uint256(param.value);\n\n        // get value\n        if (param.id == ORACLE_PARAM_ID) {\n            value = ACLOracle(param.value).canPerform(_who, _where, _what) ? 1 : 0;\n            comparedTo = 1;\n        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\n            value = blockN();\n        } else if (param.id == TIMESTAMP_PARAM_ID) {\n            value = time();\n        } else if (param.id == SENDER_PARAM_ID) {\n            value = uint256(msg.sender);\n        } else if (param.id == PARAM_VALUE_PARAM_ID) {\n            value = uint256(param.value);\n        } else {\n            if (param.id >= _how.length) {\n                return false;\n            }\n            value = uint256(uint240(_how[param.id])); // force lost precision\n        }\n\n        if (Op(param.op) == Op.RET) {\n            return uint256(value) > 0;\n        }\n\n        return compare(value, Op(param.op), comparedTo);\n    }\n\n    function evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n        if (Op(_param.op) == Op.IF_ELSE) {\n            var (condition, success, failure) = decodeParamsList(uint256(_param.value));\n            bool result = evalParam(_paramsHash, condition, _who, _where, _what, _how);\n\n            return evalParam(_paramsHash, result ? success : failure, _who, _where, _what, _how);\n        }\n\n        var (v1, v2,) = decodeParamsList(uint256(_param.value));\n        bool r1 = evalParam(_paramsHash, v1, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.NOT) {\n            return !r1;\n        }\n\n        if (r1 && Op(_param.op) == Op.OR) {\n            return true;\n        }\n\n        if (!r1 && Op(_param.op) == Op.AND) {\n            return false;\n        }\n\n        bool r2 = evalParam(_paramsHash, v2, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.XOR) {\n            return (r1 && !r2) || (!r1 && r2);\n        }\n\n        return r2; // both or and and depend on result of r2 after checks\n    }\n\n    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\n        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\n        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\n        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\n        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\n        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\n        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\n        return false;\n    }\n\n    /**\n    * @dev Internal function that sets management\n    */\n    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\n        permissionManager[roleHash(_app, _role)] = _newManager;\n        ChangePermissionManager(_app, _role, _newManager);\n    }\n\n    function roleHash(address _where, bytes32 _what) pure internal returns (bytes32) {\n        return keccak256(uint256(1), _where, _what);\n    }\n\n    function permissionHash(address _who, address _where, bytes32 _what) pure internal returns (bytes32) {\n        return keccak256(uint256(2), _who, _where, _what);\n    }\n\n    function time() internal view returns (uint64) { return uint64(block.timestamp); } // solium-disable-line security/no-block-members\n\n    function blockN() internal view returns (uint256) { return block.number; }\n}\n"
    },
    "giveth-liquidpledging/contracts/LPConstants.sol": {
      "keccak256": "0x558e8800a807b65c952c7d731ca1c5c42539d734df4d545f801ecff0f0cd2314",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-liquidpledging/contracts/LPConstants.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"@aragon/os/contracts/kernel/KernelStorage.sol\";\n\ncontract LPConstants is KernelConstants {\n    bytes32 constant public VAULT_APP_ID = keccak256(\"vault\");\n    bytes32 constant public LP_APP_ID = keccak256(\"liquidPledging\");\n}"
    },
    "giveth-common-contracts/contracts/Owned.sol": {
      "keccak256": "0x3d2c103589e6f690832f8a78ffa7fc1acacfb1393dfa47f92b76424174ca7fc1",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-common-contracts/contracts/Owned.sol"
      ],
      "content": "pragma solidity ^0.4.15;\n\n\n/// @title Owned\n/// @author Adri√† Massanet <adria@codecontext.io>\n/// @notice The Owned contract has an owner address, and provides basic \n///  authorization control functions, this simplifies & the implementation of\n///  user permissions; this contract has three work flows for a change in\n///  ownership, the first requires the new owner to validate that they have the\n///  ability to accept ownership, the second allows the ownership to be\n///  directly transfered without requiring acceptance, and the third allows for\n///  the ownership to be removed to allow for decentralization \ncontract Owned {\n\n    address public owner;\n    address public newOwnerCandidate;\n\n    event OwnershipRequested(address indexed by, address indexed to);\n    event OwnershipTransferred(address indexed from, address indexed to);\n    event OwnershipRemoved();\n\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier onlyOwner() {\n        require (msg.sender == owner);\n        _;\n    }\n    \n    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must\n    ///  be called first by the current `owner` then `acceptOwnership()` must be\n    ///  called by the `newOwnerCandidate`\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\n    ///  new owner\n    /// @param _newOwnerCandidate The address being proposed as the new owner\n    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {\n        newOwnerCandidate = _newOwnerCandidate;\n        OwnershipRequested(msg.sender, newOwnerCandidate);\n    }\n\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\n    ///  transfer of ownership\n    function acceptOwnership() public {\n        require(msg.sender == newOwnerCandidate);\n\n        address oldOwner = owner;\n        owner = newOwnerCandidate;\n        newOwnerCandidate = 0x0;\n\n        OwnershipTransferred(oldOwner, owner);\n    }\n\n    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can\n    ///  be called and it will immediately assign ownership to the `newOwner`\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    function changeOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != 0x0);\n\n        address oldOwner = owner;\n        owner = _newOwner;\n        newOwnerCandidate = 0x0;\n\n        OwnershipTransferred(oldOwner, owner);\n    }\n\n    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can\n    ///  be called and it will immediately assign ownership to the 0x0 address;\n    ///  it requires a 0xdece be input as a parameter to prevent accidental use\n    /// @notice Decentralizes the contract, this operation cannot be undone \n    /// @param _dac `0xdac` has to be entered for this function to work\n    function removeOwnership(address _dac) public onlyOwner {\n        require(_dac == 0xdac);\n        owner = 0x0;\n        newOwnerCandidate = 0x0;\n        OwnershipRemoved();     \n    }\n} \n"
    },
    "giveth-common-contracts/contracts/Escapable.sol": {
      "keccak256": "0xd8e480d59fda96249113c664c3f20b4d4f671528df8228529c995bff471c72ac",
      "urls": [
        "file:///Users/rjewing/code/giveth/lpp-dac/node_modules/giveth-common-contracts/contracts/Escapable.sol"
      ],
      "content": "pragma solidity ^0.4.15;\n/*\n    Copyright 2016, Jordi Baylina\n    Contributor: Adri√† Massanet <adria@codecontext.io>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./Owned.sol\";\nimport \"./ERC20.sol\";\n\n\n/// @dev `Escapable` is a base level contract built off of the `Owned`\n///  contract; it creates an escape hatch function that can be called in an\n///  emergency that will allow designated addresses to send any ether or tokens\n///  held in the contract to an `escapeHatchDestination` as long as they were\n///  not blacklisted\ncontract Escapable is Owned {\n    address public escapeHatchCaller;\n    address public escapeHatchDestination;\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\n\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\n    ///  `escapeHatchCaller`\n    /// @param _escapeHatchCaller The address of a trusted account or contract\n    ///  to call `escapeHatch()` to send the ether in this contract to the\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\n    ///  cannot move funds out of `escapeHatchDestination`\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract; if a neutral address\n    ///  is required, the WHG Multisig is an option:\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\n        escapeHatchCaller = _escapeHatchCaller;\n        escapeHatchDestination = _escapeHatchDestination;\n    }\n\n    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\n    ///  are the only addresses that can call a function with this modifier\n    modifier onlyEscapeHatchCallerOrOwner {\n        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\n        _;\n    }\n\n    /// @notice Creates the blacklist of tokens that are not able to be taken\n    ///  out of the contract; can only be done at the deployment, and the logic\n    ///  to add to the blacklist will be in the constructor of a child contract\n    /// @param _token the token contract address that is to be blacklisted \n    function blacklistEscapeToken(address _token) internal {\n        escapeBlacklist[_token] = true;\n        EscapeHatchBlackistedToken(_token);\n    }\n\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\n    /// @param _token the token address being queried\n    /// @return False if `_token` is in the blacklist and can't be taken out of\n    ///  the contract via the `escapeHatch()`\n    function isTokenEscapable(address _token) constant public returns (bool) {\n        return !escapeBlacklist[_token];\n    }\n\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\n    /// security issue is uncovered or something unexpected happened\n    /// @param _token to transfer, use 0x0 for ether\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \n        require(escapeBlacklist[_token]==false);\n\n        uint256 balance;\n\n        /// @dev Logic for ether\n        if (_token == 0x0) {\n            balance = this.balance;\n            escapeHatchDestination.transfer(balance);\n            EscapeHatchCalled(_token, balance);\n            return;\n        }\n        /// @dev Logic for tokens\n        ERC20 token = ERC20(_token);\n        balance = token.balanceOf(this);\n        require(token.transfer(escapeHatchDestination, balance));\n        EscapeHatchCalled(_token, balance);\n    }\n\n    /// @notice Changes the address assigned to call `escapeHatch()`\n    /// @param _newEscapeHatchCaller The address of a trusted account or\n    ///  contract to call `escapeHatch()` to send the value in this contract to\n    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\n    ///  cannot move funds out of `escapeHatchDestination`\n    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\n        escapeHatchCaller = _newEscapeHatchCaller;\n    }\n\n    event EscapeHatchBlackistedToken(address token);\n    event EscapeHatchCalled(address token, uint amount);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "abi",
          "evm.methodIdentifiers",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap"
        ]
      }
    }
  }
}