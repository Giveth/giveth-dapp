const exec = require('child_process').exec;
const fs = require('fs');

// the extra = get around having to use --allow-paths absolute_path_to_node_modules
// const solcCmd = 'solc --optimize --overwrite --pretty-json giveth-common-contracts/=node_modules/giveth-common-contracts/ = --combined-json abi,bin,bin-runtime,srcmap,srcmap-runtime -o build contracts/LiquidPledging.sol contracts/LPVault.sol contracts/EternalStorage.sol contracts/EternallyPersistentLib.sol contracts/PledgeAdmins.sol contracts/DelegateProxy.sol';// contracts/LiquidPledgingMock.sol';
const solcCmd = 'solc --optimize --overwrite --pretty-json @aragon/=node_modules/@aragon/ giveth-common-contracts/=node_modules/giveth-common-contracts/ = --combined-json abi,bin,bin-runtime,srcmap,srcmap-runtime -o build contracts/*';// contracts/LiquidPledgingMock.sol';
// const solcCmd = 'solc --optimize --overwrite --pretty-json  --combined-json abi,bin,bin-runtime,srcmap,srcmap-runtime -o build build/LiquidPledging_all.sol';// contracts/LiquidPledgingMock.sol';

const createDirIfNecessary = (dir, cb) => {
  fs.stat(dir, (err, stats) => {
    if (err) {
      fs.mkdir(dir, cb);
    } else if (!stats.isDirectory()) {
      cb(new Error(`${dir} is not a directory`));
    } else {
      cb();
    }
  });
};

function writeContractJsFile(destFile, contract, contractName, version) {
  let S = '';
  S += '/* This is an autogenerated file. DO NOT EDIT MANUALLY */\n\n';

  const abi = JSON.parse(contract.abi);
  const byteCode = contract.bin;
  const runtimeByteCode = contract[ 'bin-runtime' ];
  S += `exports.${contractName}Abi = ${JSON.stringify(abi)}\n`;
  S += `exports.${contractName}ByteCode = "0x${byteCode}"\n`;
  S += `exports.${contractName}RuntimeByteCode = "0x${runtimeByteCode}"\n`;
  S += `exports._solcVersion = "${version}"\n`;

  fs.writeFileSync(destFile, S);
}

if (fs.existsSync('build/combined.json')) {
  fs.unlinkSync('build/combined.json');
}

const p = exec(solcCmd, (err, stdout, stderr) => {
  if (err) {
    console.error('err ->', err);
  }

  console.log('stderr ->', stderr);
  console.log('stdout ->', stdout);

  const combined = JSON.parse(fs.readFileSync('build/combined.json').toString());

  createDirIfNecessary('build', (err) => {
    if (err) {
      throw err;
    }

    // only interested in LPVault & LiquidPledging
    const version = combined.version;

    const vault = combined.contracts[ "contracts/LPVault.sol:LPVault" ];
    writeContractJsFile('build/LPVault.sol.js', vault, 'LPVault', version);

    const lpFactory = combined.contracts[ "contracts/LPFactory.sol:LPFactory" ];
    writeContractJsFile('build/LPFactory.sol.js', lpFactory, 'LPFactory', version);

    const lp = combined.contracts[ "contracts/LiquidPledging.sol:LiquidPledging" ];
    writeContractJsFile('build/LiquidPledging.sol.js', lp, 'LiquidPledging', version);

    // const storage = combined.contracts[ "contracts/EternalStorage.sol:EternalStorage" ];
    // writeContractJsFile('build/EternalStorage.sol.js', storage, 'EternalStorage', version);

    // const persistence = combined.contracts[ "contracts/EternallyPersistentLib.sol:EternallyPersistentLib" ];
    // writeContractJsFile('build/EternalllyPersistentLib.sol.js', persistence, 'EternallyPersistentLib', version);

    const admins = combined.contracts[ "contracts/PledgeAdmins.sol:PledgeAdmins" ];
    writeContractJsFile('build/PledgeAdmins.sol.js', admins, 'PledgeAdmins', version);

    const mock = combined.contracts[ "contracts/LiquidPledgingMock.sol:LiquidPledgingMock" ];
    writeContractJsFile('build/LiquidPledgingMock.sol.js', mock, 'LiquidPledgingMock', version);
  });
});

