{
  "language": "Solidity",
  "sources": {
    "./contracts/ILiquidPledgingPlugin.sol": {
      "keccak256": "0x5428d88ef6856b67f0d3271065542aa4b7e6d73428b35bf1b434e5f507d3b88b",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/ILiquidPledgingPlugin.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\n/*\n    Copyright 2017, Jordi Baylina\n    Contributors: Adri√† Massanet <adria@codecontext.io>, RJ Ewing, Griff\n    Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/// @dev `ILiquidPledgingPlugin` is the basic interface for any\n///  liquid pledging plugin\ncontract ILiquidPledgingPlugin {\n\n    /// @notice Plugins are used (much like web hooks) to initiate an action\n    ///  upon any donation, delegation, or transfer; this is an optional feature\n    ///  and allows for extreme customization of the contract. This function\n    ///  implements any action that should be initiated before a transfer.\n    /// @param pledgeManager The admin or current manager of the pledge\n    /// @param pledgeFrom This is the Id from which value will be transfered.\n    /// @param pledgeTo This is the Id that value will be transfered to.    \n    /// @param context The situation that is triggering the plugin:\n    ///  0 -> Plugin for the owner transferring pledge to another party\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\n    ///  ...\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n    ///\n    ///  256 -> Plugin for the owner receiving pledge to another party\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\n    ///  ...\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n    /// @param amount The amount of value that will be transfered.\n    function beforeTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount ) public returns (uint maxAllowed);\n\n    /// @notice Plugins are used (much like web hooks) to initiate an action\n    ///  upon any donation, delegation, or transfer; this is an optional feature\n    ///  and allows for extreme customization of the contract. This function\n    ///  implements any action that should be initiated after a transfer.\n    /// @param pledgeManager The admin or current manager of the pledge\n    /// @param pledgeFrom This is the Id from which value will be transfered.\n    /// @param pledgeTo This is the Id that value will be transfered to.    \n    /// @param context The situation that is triggering the plugin:\n    ///  0 -> Plugin for the owner transferring pledge to another party\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\n    ///  ...\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n    ///\n    ///  256 -> Plugin for the owner receiving pledge to another party\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\n    ///  ...\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n    ///  @param amount The amount of value that will be transfered.\n    function afterTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount\n    ) public;\n}\n"
    },
    "./contracts/LPFactory.sol": {
      "keccak256": "0x24986a9eb2cbc057f7816e2da5d1054d6b1b64f5542c09a3f3abfc77da2630dc",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LPFactory.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"@aragon/os/contracts/factory/DAOFactory.sol\";\nimport \"./LPVault.sol\";\nimport \"./LiquidPledging.sol\";\nimport \"./LPConstants.sol\";\n\ncontract LPFactory is LPConstants, DAOFactory {\n    address public vaultBase;\n    address public lpBase;\n\n    event DeployVault(address vault);\n    event DeployLiquidPledging(address liquidPledging);\n\n    function LPFactory(address _vaultBase, address _lpBase) public DAOFactory(0) {\n        require(_vaultBase != 0);\n        require(_lpBase != 0);\n        vaultBase = _vaultBase;\n        lpBase = _lpBase;\n    }\n\n    function newLP(address _root, address _escapeHatchDestination) external {\n        Kernel kernel = newDAO(this);\n        ACL acl = ACL(kernel.acl());\n\n        bytes32 appManagerRole = kernel.APP_MANAGER_ROLE();\n\n        acl.createPermission(this, address(kernel), appManagerRole, this);\n\n        LPVault v = LPVault(kernel.newAppInstance(VAULT_APP_ID, vaultBase));\n        LiquidPledging lp = LiquidPledging(kernel.newAppInstance(LP_APP_ID, lpBase));\n        v.initialize(address(lp), _escapeHatchDestination);\n        lp.initialize(address(v), _escapeHatchDestination);\n\n        // register the lp instance w/ the kernel\n        kernel.setApp(kernel.APP_ADDR_NAMESPACE(), LP_APP_ID, address(lp));\n\n        _setPermissions(_root, acl, kernel, v, lp);\n    }\n\n    function _setPermissions(address _root, ACL acl, Kernel kernel, LPVault v, LiquidPledging lp) internal {\n        bytes32 appManagerRole = kernel.APP_MANAGER_ROLE();\n        bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n        bytes32 hatchCallerRole = v.ESCAPE_HATCH_CALLER_ROLE();\n        bytes32 pluginManagerRole = lp.PLUGIN_MANAGER_ROLE();\n\n        acl.createPermission(_root, address(v), hatchCallerRole, _root);\n        acl.createPermission(_root, address(lp), hatchCallerRole, _root);\n        acl.createPermission(_root, address(lp), pluginManagerRole, _root);\n        // TODO: set pledgeAdminRole manager to 0x0? maybe it doesn't matter b/c it can be recreated by _root anyways\n\n        acl.grantPermission(_root, address(kernel), appManagerRole);\n        acl.grantPermission(_root, address(acl), permRole);\n        acl.revokePermission(this, address(kernel), appManagerRole);\n        acl.revokePermission(this, address(acl), permRole);\n\n        acl.setPermissionManager(_root, address(kernel), appManagerRole);\n        acl.setPermissionManager(_root, address(acl), permRole);\n\n        DeployVault(address(v));\n        DeployLiquidPledging(address(lp));\n    }\n}"
    },
    "@aragon/os/contracts/acl/IACL.sol": {
      "keccak256": "0xa120fc32d8d2c5096d605b0fe012d5b1e4a62118952a25a18bac5210f4fceede",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/acl/IACL.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IACL {\n    function initialize(address permissionsCreator) public;\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}\n"
    },
    "@aragon/os/contracts/kernel/IKernel.sol": {
      "keccak256": "0xc4bd88d7355351f68614906f04d7a67b4fcd81b28112f75df090b7eb8b93c881",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/kernel/IKernel.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../acl/IACL.sol\";\n\ninterface IKernel {\n    event SetApp(bytes32 indexed namespace, bytes32 indexed name, bytes32 indexed id, address app);\n\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 name, address app) public returns (bytes32 id);\n    function getApp(bytes32 id) public view returns (address);\n}"
    },
    "@aragon/os/contracts/kernel/KernelStorage.sol": {
      "keccak256": "0x5eeaeb6e75a435278d5a2d74dab865bd9c2a88fba296db5b8669769d6a60573e",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/kernel/KernelStorage.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract KernelConstants {\n    bytes32 constant public CORE_NAMESPACE = keccak256(\"core\");\n    bytes32 constant public APP_BASES_NAMESPACE = keccak256(\"base\");\n    bytes32 constant public APP_ADDR_NAMESPACE = keccak256(\"app\");\n\n    bytes32 constant public KERNEL_APP_ID = keccak256(\"kernel.aragonpm.eth\");\n    bytes32 constant public KERNEL_APP = keccak256(CORE_NAMESPACE, KERNEL_APP_ID);\n\n    bytes32 constant public ACL_APP_ID = keccak256(\"acl.aragonpm.eth\");\n    bytes32 constant public ACL_APP = keccak256(APP_ADDR_NAMESPACE, ACL_APP_ID);\n}\n\n\ncontract KernelStorage is KernelConstants {\n    mapping (bytes32 => address) public apps;\n}\n"
    },
    "@aragon/os/contracts/acl/ACLSyntaxSugar.sol": {
      "keccak256": "0x92c85fe20e03c5fde11c3006b2acd7c24021d53356bd14070522d71912e5419b",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract ACLSyntaxSugar {\n    function arr() internal pure returns (uint256[] r) {}\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}\n\n\ncontract ACLHelpers {\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/IAppProxy.sol": {
      "keccak256": "0x4d5f398f887030d6d0b5045e0424b59d58abd718143289afcaf3e160d6c91736",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/apps/IAppProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\ninterface IAppProxy {\n    function isUpgradeable() public pure returns (bool);\n    function getCode() public view returns (address);\n}\n"
    },
    "@aragon/os/contracts/apps/AppStorage.sol": {
      "keccak256": "0x8b9205a3fdf9d94fb1461d2c2d32335803122aa75d3fa8cf0b982796fd040c25",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/apps/AppStorage.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppStorage {\n    IKernel public kernel;\n    bytes32 public appId;\n    address internal pinnedCode; // used by Proxy Pinned\n    uint256 internal initializationBlock; // used by Initializable\n    uint256[95] private storageOffset; // forces App storage to start at after 100 slots\n    uint256 private offset;\n}\n"
    },
    "@aragon/os/contracts/common/Initializable.sol": {
      "keccak256": "0x07ef04e0cf56217c5e103a760dd577a7fffa06ca166dc15af35b3895e58880e9",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/common/Initializable.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../apps/AppStorage.sol\";\n\n\ncontract Initializable is AppStorage {\n    modifier onlyInit {\n        require(initializationBlock == 0);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        initializationBlock = getBlockNumber();\n    }\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "@aragon/os/contracts/common/DelegateProxy.sol": {
      "keccak256": "0x81bab220700a9a5def3ac54278ccec046be0b1c333dba9567f7175e358414d87",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/common/DelegateProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract DelegateProxy {\n    /**\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n    * @param _dst Destination address to perform the delegatecall\n    * @param _calldata Calldata for the delegatecall\n    */\n    function delegatedFwd(address _dst, bytes _calldata) internal {\n        require(isContract(_dst));\n        assembly {\n            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            let size := returndatasize\n\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n\n    function isContract(address _target) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/AppProxyBase.sol": {
      "keccak256": "0x907218cac02c5f7a10873eb30fb1ffaecdd93527a0ff7e2f0305590bf585d06b",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/apps/AppProxyBase.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./IAppProxy.sol\";\nimport \"./AppStorage.sol\";\nimport \"../common/DelegateProxy.sol\";\nimport \"../kernel/KernelStorage.sol\";\n\n\ncontract AppProxyBase is IAppProxy, AppStorage, DelegateProxy, KernelConstants {\n    /**\n    * @dev Initialize AppProxy\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyBase(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n        kernel = _kernel;\n        appId = _appId;\n\n        // Implicit check that kernel is actually a Kernel\n        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\n        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n        // it.\n        address appCode = getAppBase(appId);\n\n        // If initialize payload is provided, it will be executed\n        if (_initializePayload.length > 0) {\n            require(isContract(appCode));\n            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n            // returns ending execution context and halts contract deployment\n            require(appCode.delegatecall(_initializePayload));\n        }\n    }\n\n    function getAppBase(bytes32 _appId) internal view returns (address) {\n        return kernel.getApp(keccak256(APP_BASES_NAMESPACE, _appId));\n    }\n\n    function () payable public {\n        address target = getCode();\n        require(target != 0); // if app code hasn't been set yet, don't call\n        delegatedFwd(target, msg.data);\n    }\n}"
    },
    "@aragon/os/contracts/apps/AppProxyUpgradeable.sol": {
      "keccak256": "0x4613af6e313048b7de649d54630276fb18154dac5674f057109f0e0591f11cb2",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/apps/AppProxyUpgradeable.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyUpgradeable is AppProxyBase {\n    address public pinnedCode;\n\n    /**\n    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyUpgradeable(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n\n    }\n\n    function getCode() public view returns (address) {\n        return getAppBase(appId);\n    }\n\n    function isUpgradeable() public pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "@aragon/os/contracts/apps/AppProxyPinned.sol": {
      "keccak256": "0xfe66e88413adc4d60ae53352046bd23ebd0aeb3120599d445df19caa8b095c26",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/apps/AppProxyPinned.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyPinned is AppProxyBase {\n    /**\n    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n        pinnedCode = getAppBase(appId);\n        require(pinnedCode != address(0));\n    }\n\n    function getCode() public view returns (address) {\n        return pinnedCode;\n    }\n\n    function isUpgradeable() public pure returns (bool) {\n        return false;\n    }\n\n    function () payable public {\n        delegatedFwd(getCode(), msg.data);\n    }\n}"
    },
    "@aragon/os/contracts/factory/AppProxyFactory.sol": {
      "keccak256": "0xa5314f57f93d8e633724bd9f94ad43f127c5b5466dcd0ef32fe0f78d5d431592",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/factory/AppProxyFactory.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AppProxyUpgradeable.sol\";\nimport \"../apps/AppProxyPinned.sol\";\n\n\ncontract AppProxyFactory {\n    event NewAppProxy(address proxy);\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n        return newAppProxy(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy));\n        return proxy;\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy));\n        return proxy;\n    }\n}\n"
    },
    "@aragon/os/contracts/kernel/Kernel.sol": {
      "keccak256": "0x0525a68271476d181b698069adf27074e3d5f058a331b71424479489df30694d",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/kernel/Kernel.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./IKernel.sol\";\nimport \"./KernelStorage.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../apps/IAppProxy.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../factory/AppProxyFactory.sol\";\n\n\ncontract Kernel is IKernel, KernelStorage, Initializable, AppProxyFactory, ACLSyntaxSugar {\n    bytes32 constant public APP_MANAGER_ROLE = bytes32(1);\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes a kernel instance along with its ACL and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _baseAcl Address of base ACL app\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _baseAcl, address _permissionsCreator) onlyInit public {\n        initialized();\n\n        IACL acl = IACL(newAppProxy(this, ACL_APP_ID));\n\n        _setApp(APP_BASES_NAMESPACE, ACL_APP_ID, _baseAcl);\n        _setApp(APP_ADDR_NAMESPACE, ACL_APP_ID, acl);\n\n        acl.initialize(_permissionsCreator);\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel and set its base\n    *      implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (IAppProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxy(this, _name);\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel and set\n    *      its base implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (IAppProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxyPinned(this, _name);\n    }\n\n    /**\n    * @dev Set the resolving address of an app instance or base implementation\n    * @param _namespace App namespace to use\n    * @param _name Name of the app\n    * @param _app Address of the app\n    * @return ID of app\n    */\n    function setApp(bytes32 _namespace, bytes32 _name, address _app) auth(APP_MANAGER_ROLE, arr(_namespace, _name)) kernelIntegrity public returns (bytes32 id) {\n        return _setApp(_namespace, _name, _app);\n    }\n\n    /**\n    * @dev Get the address of an app instance or base implementation\n    * @param _id App identifier\n    * @return Address of the app\n    */\n    function getApp(bytes32 _id) public view returns (address) {\n        return apps[_id];\n    }\n\n    /**\n    * @dev Get the installed ACL app\n    * @return ACL app\n    */\n    function acl() public view returns (IACL) {\n        return IACL(getApp(ACL_APP));\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission status\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _what Identifier for a group of actions in app\n    * @param _how Extra data for ACL auth\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\n        return acl().hasPermission(_who, _where, _what, _how);\n    }\n\n    function _setApp(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        id = keccak256(_namespace, _name);\n        apps[id] = _app;\n        SetApp(_namespace, _name, id, _app);\n    }\n\n    function _setAppIfNew(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        id = keccak256(_namespace, _name);\n\n        if (_app != address(0)) {\n            address app = getApp(id);\n            if (app != address(0)) {\n                require(app == _app);\n            } else {\n                apps[id] = _app;\n                SetApp(_namespace, _name, id, _app);\n            }\n        }\n    }\n\n    modifier auth(bytes32 _role, uint256[] memory params) {\n        bytes memory how;\n        uint256 byteLength = params.length * 32;\n        assembly {\n            how := params // forced casting\n            mstore(how, byteLength)\n        }\n        // Params is invalid from this point fwd\n        require(hasPermission(msg.sender, address(this), _role, how));\n        _;\n    }\n\n    modifier kernelIntegrity {\n        _; // After execution check integrity\n        address kernel = getApp(KERNEL_APP);\n        uint256 size;\n        assembly { size := extcodesize(kernel) }\n        require(size > 0);\n    }\n}\n"
    },
    "@aragon/os/contracts/kernel/KernelProxy.sol": {
      "keccak256": "0xe9baab334f8e30a2d9a4fb21a54b46a6603597f812deef2ec36215491e6dcf11",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/kernel/KernelProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./KernelStorage.sol\";\nimport \"../common/DelegateProxy.sol\";\n\n\ncontract KernelProxy is KernelStorage, DelegateProxy {\n    /**\n    * @dev KernelProxy is a proxy contract to a kernel implementation. The implementation\n    *      can update the reference, which effectively upgrades the contract\n    * @param _kernelImpl Address of the contract used as implementation for kernel\n    */\n    function KernelProxy(address _kernelImpl) public {\n        apps[keccak256(CORE_NAMESPACE, KERNEL_APP_ID)] = _kernelImpl;\n    }\n\n    /**\n    * @dev All calls made to the proxy are forwarded to the kernel implementation via a delegatecall\n    * @return Any bytes32 value the implementation returns\n    */\n    function () payable public {\n        delegatedFwd(apps[KERNEL_APP], msg.data);\n    }\n}"
    },
    "@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol": {
      "keccak256": "0x6a4beed810085f11cda9d50c3547ac4cc2100d9dc18ab4982ff11dd483410012",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IEVMScriptExecutor {\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n}\n"
    },
    "@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol": {
      "keccak256": "0xa0cf92b96ee915266c74d42f3479ee809754264cc783fe9635f74d3795c7b2e1",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract EVMScriptRegistryConstants {\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = keccak256(\"evmreg.aragonpm.eth\");\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP = keccak256(keccak256(\"app\"), EVMSCRIPT_REGISTRY_APP_ID);\n}\n\n\ninterface IEVMScriptRegistry {\n    function addScriptExecutor(address executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    function getScriptExecutor(bytes script) public view returns (address);\n}"
    },
    "@aragon/os/contracts/evmscript/ScriptHelpers.sol": {
      "keccak256": "0x21a99d2fc9de2244829954ea1c21057f25f74a23f18ac7f7402420922e287517",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\nlibrary ScriptHelpers {\n    // To test with JS and compare with actual encoder. Maintaining for reference.\n    // t = function() { return IEVMScriptExecutor.at('0x4bcdd59d6c77774ee7317fc1095f69ec84421e49').contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\n    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\n    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\n\n    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\n        return encode(_a, _b, _c);\n    }\n\n    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\n        // A is positioned after the 3 position words\n        uint256 aPosition = 0x60;\n        uint256 bPosition = aPosition + 32 * abiLength(_a);\n        uint256 cPosition = bPosition + 32 * abiLength(_b);\n        uint256 length = cPosition + 32 * abiLength(_c);\n\n        d = new bytes(length);\n        assembly {\n            // Store positions\n            mstore(add(d, 0x20), aPosition)\n            mstore(add(d, 0x40), bPosition)\n            mstore(add(d, 0x60), cPosition)\n        }\n\n        // Copy memory to correct position\n        copy(d, getPtr(_a), aPosition, _a.length);\n        copy(d, getPtr(_b), bPosition, _b.length);\n        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\n    }\n\n    function abiLength(bytes memory _a) internal pure returns (uint256) {\n        // 1 for length +\n        // memory words + 1 if not divisible for 32 to offset word\n        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\n    }\n\n    function abiLength(address[] _a) internal pure returns (uint256) {\n        // 1 for length + 1 per item\n        return 1 + _a.length;\n    }\n\n    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\n        uint dest;\n        assembly {\n            dest := add(add(_d, 0x20), _pos)\n        }\n        memcpy(dest, _src, _length + 32);\n    }\n\n    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getSpecId(bytes _script) internal pure returns (uint32) {\n        return uint32At(_script, 0);\n    }\n\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := mload(add(_data, add(0x20, _location)))\n        }\n    }\n\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n            0x1000000000000000000000000)\n        }\n    }\n\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n            0x100000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := add(_data, add(0x20, _location))\n        }\n    }\n\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n        bytes memory payload = new bytes(4);\n        payload[0] = bytes1(_sig);\n        payload[1] = bytes1(_sig << 8);\n        payload[2] = bytes1(_sig << 16);\n        payload[3] = bytes1(_sig << 24);\n        return payload;\n    }\n\n    function memcpy(uint _dest, uint _src, uint _len) public pure {\n        uint256 src = _src;\n        uint256 dest = _dest;\n        uint256 len = _len;\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}"
    },
    "@aragon/os/contracts/evmscript/EVMScriptRunner.sol": {
      "keccak256": "0xf226f2c5c0a930340d49a5f79ac49a18dc0f88632acdef32c4eb698d5bb8a77e",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../apps/AppStorage.sol\";\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"./ScriptHelpers.sol\";\n\n\ncontract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {\n    using ScriptHelpers for bytes;\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {\n        // TODO: Too much data flying around, maybe extracting spec id here is cheaper\n        address executorAddr = getExecutor(_script);\n        require(executorAddr != address(0));\n\n        bytes memory calldataArgs = _script.encode(_input, _blacklist);\n        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;\n\n        require(executorAddr.delegatecall(sig, calldataArgs));\n\n        return returnedDataDecoded();\n    }\n\n    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));\n    }\n\n    // TODO: Internal\n    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    /**\n    * @dev copies and returns last's call data. Needs to ABI decode first\n    */\n    function returnedDataDecoded() internal view returns (bytes ret) {\n        assembly {\n            let size := returndatasize\n            switch size\n            case 0 {}\n            default {\n                ret := mload(0x40) // free mem ptr get\n                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data\n            }\n        }\n        return ret;\n    }\n\n    modifier protectState {\n        address preKernel = kernel;\n        bytes32 preAppId = appId;\n        _; // exec\n        require(kernel == preKernel);\n        require(appId == preAppId);\n    }\n}"
    },
    "@aragon/os/contracts/apps/AragonApp.sol": {
      "keccak256": "0x7b5ed0ab203aea14886f337bc8b73ec49177415d43b3251d917d51a6d138d8f1",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/apps/AragonApp.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./AppStorage.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../evmscript/EVMScriptRunner.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\n\n\ncontract AragonApp is AppStorage, Initializable, ACLSyntaxSugar, EVMScriptRunner {\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)));\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] params) {\n        require(canPerform(msg.sender, _role, params));\n        _;\n    }\n\n    function canPerform(address _sender, bytes32 _role, uint256[] params) public view returns (bool) {\n        bytes memory how; // no need to init memory as it is never used\n        if (params.length > 0) {\n            uint256 byteLength = params.length * 32;\n            assembly {\n                how := params // forced casting\n                mstore(how, byteLength)\n            }\n        }\n        return address(kernel) == 0 || kernel.hasPermission(_sender, address(this), _role, how);\n    }\n}\n"
    },
    "@aragon/os/contracts/acl/ACL.sol": {
      "keccak256": "0x7e636d70192cc2b18d00df37ff91e1f3b4e5a6dfb0c92f9d90441dceac1f2a25",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/acl/ACL.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AragonApp.sol\";\nimport \"./ACLSyntaxSugar.sol\";\nimport \"./IACL.sol\";\n\n\ninterface ACLOracle {\n    function canPerform(address who, address where, bytes32 what) public view returns (bool);\n}\n\n\ncontract ACL is IACL, AragonApp, ACLHelpers {\n    bytes32 constant public CREATE_PERMISSIONS_ROLE = bytes32(1);\n\n    // whether a certain entity has a permission\n    mapping (bytes32 => bytes32) permissions; // 0 for no permission, or parameters id\n    mapping (bytes32 => Param[]) public permissionParams;\n\n    // who is the manager of a permission\n    mapping (bytes32 => address) permissionManager;\n\n    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, NOT, AND, OR, XOR, IF_ELSE, RET } // op types\n\n    struct Param {\n        uint8 id;\n        uint8 op;\n        uint240 value; // even though value is an uint240 it can store addresses\n        // in the case of 32 byte hashes losing 2 bytes precision isn't a huge deal\n        // op and id take less than 1 byte each so it can be kept in 1 sstore\n    }\n\n    uint8 constant BLOCK_NUMBER_PARAM_ID = 200;\n    uint8 constant TIMESTAMP_PARAM_ID    = 201;\n    uint8 constant SENDER_PARAM_ID       = 202;\n    uint8 constant ORACLE_PARAM_ID       = 203;\n    uint8 constant LOGIC_OP_PARAM_ID     = 204;\n    uint8 constant PARAM_VALUE_PARAM_ID  = 205;\n    // TODO: Add execution times param type?\n\n    bytes32 constant public EMPTY_PARAM_HASH = keccak256(uint256(0));\n    address constant ANY_ENTITY = address(-1);\n\n    modifier onlyPermissionManager(address _app, bytes32 _role) {\n        require(msg.sender == getPermissionManager(_app, _role));\n        _;\n    }\n\n    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\n    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes an ACL instance and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _permissionsCreator) onlyInit public {\n        initialized();\n        require(msg.sender == address(kernel));\n\n        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\n    }\n\n    /**\n    * @dev Creates a permission that wasn't previously set. Access is limited by the ACL.\n    *      If a created permission is removed it is possible to reset it with createPermission.\n    * @notice Create a new permission granting `_entity` the ability to perform actions of role `_role` on `_app` (setting `_manager` as the permission manager)\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\n    */\n    function createPermission(address _entity, address _app, bytes32 _role, address _manager) external {\n        require(hasPermission(msg.sender, address(this), CREATE_PERMISSIONS_ROLE));\n\n        _createPermission(_entity, _app, _role, _manager);\n    }\n\n    /**\n    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    */\n    function grantPermission(address _entity, address _app, bytes32 _role)\n        external\n    {\n        grantPermissionP(_entity, _app, _role, new uint256[](0));\n    }\n\n    /**\n    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _params Permission parameters\n    */\n    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\n        onlyPermissionManager(_app, _role)\n        public\n    {\n        require(!hasPermission(_entity, _app, _role));\n\n        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\n        _setPermission(_entity, _app, _role, paramsHash);\n    }\n\n    /**\n    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\n    * @notice Revokes `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity to revoke access from\n    * @param _app Address of the app in which the role will be revoked\n    * @param _role Identifier for the group of actions in app being revoked\n    */\n    function revokePermission(address _entity, address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        require(hasPermission(_entity, _app, _role));\n\n        _setPermission(_entity, _app, _role, bytes32(0));\n    }\n\n    /**\n    * @notice Sets `_newManager` as the manager of the permission `_role` in `_app`\n    * @param _newManager Address for the new manager\n    * @param _app Address of the app in which the permission management is being transferred\n    * @param _role Identifier for the group of actions being transferred\n    */\n    function setPermissionManager(address _newManager, address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        _setPermissionManager(_newManager, _app, _role);\n    }\n\n    /**\n    * @dev Get manager for permission\n    * @param _app Address of the app\n    * @param _role Identifier for a group of actions in app\n    * @return address of the manager for the permission\n    */\n    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\n        return permissionManager[roleHash(_app, _role)];\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission statu\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _where Identifier for a group of actions in app\n    * @param _how Permission parameters\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\n        uint256[] memory how;\n        uint256 intsLength = _how.length / 32;\n        assembly {\n            how := _how // forced casting\n            mstore(how, intsLength)\n        }\n        // _how is invalid from this point fwd\n        return hasPermission(_who, _where, _what, how);\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\n        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\n        if (whoParams != bytes32(0) && evalParams(whoParams, _who, _where, _what, _how)) {\n            return true;\n        }\n\n        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\n        if (anyParams != bytes32(0) && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\n        uint256[] memory empty = new uint256[](0);\n        return hasPermission(_who, _where, _what, empty);\n    }\n\n    /**\n    * @dev Internal createPermission for access inside the kernel (on instantiation)\n    */\n    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\n        // only allow permission creation (or re-creation) when there is no manager\n        require(getPermissionManager(_app, _role) == address(0));\n\n        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\n        _setPermissionManager(_manager, _app, _role);\n    }\n\n    /**\n    * @dev Internal function called to actually save the permission\n    */\n    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\n        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\n\n        SetPermission(_entity, _app, _role, _paramsHash != bytes32(0));\n    }\n\n    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\n        bytes32 paramHash = keccak256(_encodedParams);\n        Param[] storage params = permissionParams[paramHash];\n\n        if (params.length == 0) { // params not saved before\n            for (uint256 i = 0; i < _encodedParams.length; i++) {\n                uint256 encodedParam = _encodedParams[i];\n                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\n                params.push(param);\n            }\n        }\n\n        return paramHash;\n    }\n\n    function evalParams(\n        bytes32 _paramsHash,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) internal view returns (bool)\n    {\n        if (_paramsHash == EMPTY_PARAM_HASH) {\n            return true;\n        }\n\n        return evalParam(_paramsHash, 0, _who, _where, _what, _how);\n    }\n\n    function evalParam(\n        bytes32 _paramsHash,\n        uint32 _paramId,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) internal view returns (bool)\n    {\n        if (_paramId >= permissionParams[_paramsHash].length) {\n            return false; // out of bounds\n        }\n\n        Param memory param = permissionParams[_paramsHash][_paramId];\n\n        if (param.id == LOGIC_OP_PARAM_ID) {\n            return evalLogic(param, _paramsHash, _who, _where, _what, _how);\n        }\n\n        uint256 value;\n        uint256 comparedTo = uint256(param.value);\n\n        // get value\n        if (param.id == ORACLE_PARAM_ID) {\n            value = ACLOracle(param.value).canPerform(_who, _where, _what) ? 1 : 0;\n            comparedTo = 1;\n        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\n            value = blockN();\n        } else if (param.id == TIMESTAMP_PARAM_ID) {\n            value = time();\n        } else if (param.id == SENDER_PARAM_ID) {\n            value = uint256(msg.sender);\n        } else if (param.id == PARAM_VALUE_PARAM_ID) {\n            value = uint256(param.value);\n        } else {\n            if (param.id >= _how.length) {\n                return false;\n            }\n            value = uint256(uint240(_how[param.id])); // force lost precision\n        }\n\n        if (Op(param.op) == Op.RET) {\n            return uint256(value) > 0;\n        }\n\n        return compare(value, Op(param.op), comparedTo);\n    }\n\n    function evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n        if (Op(_param.op) == Op.IF_ELSE) {\n            var (condition, success, failure) = decodeParamsList(uint256(_param.value));\n            bool result = evalParam(_paramsHash, condition, _who, _where, _what, _how);\n\n            return evalParam(_paramsHash, result ? success : failure, _who, _where, _what, _how);\n        }\n\n        var (v1, v2,) = decodeParamsList(uint256(_param.value));\n        bool r1 = evalParam(_paramsHash, v1, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.NOT) {\n            return !r1;\n        }\n\n        if (r1 && Op(_param.op) == Op.OR) {\n            return true;\n        }\n\n        if (!r1 && Op(_param.op) == Op.AND) {\n            return false;\n        }\n\n        bool r2 = evalParam(_paramsHash, v2, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.XOR) {\n            return (r1 && !r2) || (!r1 && r2);\n        }\n\n        return r2; // both or and and depend on result of r2 after checks\n    }\n\n    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\n        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\n        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\n        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\n        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\n        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\n        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\n        return false;\n    }\n\n    /**\n    * @dev Internal function that sets management\n    */\n    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\n        permissionManager[roleHash(_app, _role)] = _newManager;\n        ChangePermissionManager(_app, _role, _newManager);\n    }\n\n    function roleHash(address _where, bytes32 _what) pure internal returns (bytes32) {\n        return keccak256(uint256(1), _where, _what);\n    }\n\n    function permissionHash(address _who, address _where, bytes32 _what) pure internal returns (bytes32) {\n        return keccak256(uint256(2), _who, _where, _what);\n    }\n\n    function time() internal view returns (uint64) { return uint64(block.timestamp); } // solium-disable-line security/no-block-members\n\n    function blockN() internal view returns (uint256) { return block.number; }\n}\n"
    },
    "@aragon/os/contracts/evmscript/EVMScriptRegistry.sol": {
      "keccak256": "0xd2b72c173913aa2b869e6185843e3796e0532b9744a10fdf0ac7ec532e5b0fff",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/evmscript/EVMScriptRegistry.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./ScriptHelpers.sol\";\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"../apps/AragonApp.sol\";\n\n\ncontract EVMScriptRegistry is IEVMScriptRegistry, EVMScriptRegistryConstants, AragonApp {\n    using ScriptHelpers for bytes;\n\n    // WARN: Manager can censor all votes and the like happening in an org\n    bytes32 constant public REGISTRY_MANAGER_ROLE = bytes32(1);\n\n    struct ExecutorEntry {\n        address executor;\n        bool enabled;\n    }\n\n    ExecutorEntry[] public executors;\n\n    function initialize() onlyInit public {\n        initialized();\n        // Create empty record to begin executor IDs at 1\n        executors.push(ExecutorEntry(address(0), false));\n    }\n\n    function addScriptExecutor(address _executor) external auth(REGISTRY_MANAGER_ROLE) returns (uint id) {\n        return executors.push(ExecutorEntry(_executor, true));\n    }\n\n    function disableScriptExecutor(uint256 _executorId) external auth(REGISTRY_MANAGER_ROLE) {\n        executors[_executorId].enabled = false;\n    }\n\n    function getScriptExecutor(bytes _script) public view returns (address) {\n        uint256 id = _script.getSpecId();\n\n        if (id == 0 || id >= executors.length) {\n            return address(0);\n        }\n\n        ExecutorEntry storage entry = executors[id];\n        return entry.enabled ? entry.executor : address(0);\n    }\n}\n"
    },
    "@aragon/os/contracts/evmscript/executors/CallsScript.sol": {
      "keccak256": "0x72ff2681f5dfec19b05d235d841042a78a4682a8368e6bb16516447495161014",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/evmscript/executors/CallsScript.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n// Inspired by https://github.com/reverendus/tx-manager\n\nimport \"../ScriptHelpers.sol\";\nimport \"../IEVMScriptExecutor.sol\";\n\n\ncontract CallsScript is IEVMScriptExecutor {\n    using ScriptHelpers for bytes;\n\n    uint256 constant internal SCRIPT_START_LOCATION = 4;\n\n    event LogScriptCall(address indexed sender, address indexed src, address indexed dst);\n\n    /**\n    * @notice Executes a number of call scripts\n    * @param _script [ specId (uint32) ] many calls with this structure ->\n    *    [ to (address: 20 bytes) ] [ calldataLength (uint32: 4 bytes) ] [ calldata (calldataLength bytes) ]\n    * @param _input Input is ignored in callscript\n    * @param _blacklist Addresses the script cannot call to, or will revert.\n    * @return always returns empty byte array\n    */\n    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n        uint256 location = SCRIPT_START_LOCATION; // first 32 bits are spec id\n        while (location < _script.length) {\n            address contractAddress = _script.addressAt(location);\n            // Check address being called is not blacklist\n            for (uint i = 0; i < _blacklist.length; i++) {\n                require(contractAddress != _blacklist[i]);\n            }\n\n            // logged before execution to ensure event ordering in receipt\n            // if failed entire execution is reverted regardless\n            LogScriptCall(msg.sender, address(this), contractAddress);\n\n            uint256 calldataLength = uint256(_script.uint32At(location + 0x14));\n            uint256 calldataStart = _script.locationOf(location + 0x14 + 0x04);\n\n            assembly {\n                let success := call(sub(gas, 5000), contractAddress, 0, calldataStart, calldataLength, 0, 0)\n                switch success case 0 { revert(0, 0) }\n            }\n\n            location += (0x14 + 0x04 + calldataLength);\n        }\n    }\n}"
    },
    "@aragon/os/contracts/evmscript/executors/DelegateScript.sol": {
      "keccak256": "0x1f29ea7d6d6f912b392f3fc4b9dad4cfbe5f2133fbdf21e8233a999a6726858a",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/evmscript/executors/DelegateScript.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../ScriptHelpers.sol\";\nimport \"../IEVMScriptExecutor.sol\";\n\n\ninterface DelegateScriptTarget {\n    function exec() public;\n}\n\n\ncontract DelegateScript is IEVMScriptExecutor {\n    using ScriptHelpers for *;\n\n    uint256 constant internal SCRIPT_START_LOCATION = 4;\n\n    /**\n    * @notice Executes script by delegatecall into a contract\n    * @param _script [ specId (uint32) ][ contract address (20 bytes) ]\n    * @param _input ABI encoded call to be made to contract (if empty executes default exec() function)\n    * @param _blacklist If any address is passed, will revert.\n    * @return Call return data\n    */\n    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n        require(_blacklist.length == 0); // dont have ability to control bans, so fail.\n\n        // Script should be spec id + address (20 bytes)\n        require(_script.length == SCRIPT_START_LOCATION + 20);\n        return delegate(_script.addressAt(SCRIPT_START_LOCATION), _input);\n    }\n\n    /**\n    * @dev Delegatecall to contract with input data\n    */\n    function delegate(address _addr, bytes memory _input) internal returns (bytes memory output) {\n        require(isContract(_addr));\n        require(_addr.delegatecall(_input.length > 0 ? _input : defaultInput()));\n        return returnedData();\n    }\n\n    function isContract(address _target) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n\n    function defaultInput() internal pure returns (bytes) {\n        return DelegateScriptTarget(0).exec.selector.toBytes();\n    }\n\n    /**\n    * @dev copies and returns last's call data\n    */\n    function returnedData() internal view returns (bytes ret) {\n        assembly {\n            let size := returndatasize\n            ret := mload(0x40) // free mem ptr get\n            mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n            mstore(ret, size) // set array length\n            returndatacopy(add(ret, 0x20), 0, size) // copy return data\n        }\n        return ret;\n    }\n}"
    },
    "@aragon/os/contracts/evmscript/executors/DeployDelegateScript.sol": {
      "keccak256": "0x664ae058059e6b64e38a2f0c56c4c1603de64de56270fab1992cf64d721f1233",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/evmscript/executors/DeployDelegateScript.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./DelegateScript.sol\";\n\n// Inspired by: https://github.com/dapphub/ds-proxy/blob/master/src/proxy.sol\n\n\ncontract DeployDelegateScript is DelegateScript {\n    uint256 constant internal SCRIPT_START_LOCATION = 4;\n\n    mapping (bytes32 => address) cache;\n\n    /**\n    * @notice Executes script by delegatecall into a deployed contract (exec() function)\n    * @param _script [ specId (uint32) ][ contractInitcode (bytecode) ]\n    * @param _input ABI encoded call to be made to contract (if empty executes default exec() function)\n    * @param _blacklist If any address is passed, will revert.\n    * @return Call return data\n    */\n    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n        require(_blacklist.length == 0); // dont have ability to control bans, so fail.\n\n        bytes32 id = keccak256(_script);\n        address deployed = cache[id];\n        if (deployed == address(0)) {\n            deployed = deploy(_script);\n            cache[id] = deployed;\n        }\n\n        return DelegateScript.delegate(deployed, _input);\n    }\n\n    /**\n    * @dev Deploys contract byte code to network\n    */\n    function deploy(bytes _script) internal returns (address addr) {\n        assembly {\n            // 0x24 = 0x20 (length) + 0x04 (spec id uint32)\n            // Length of code is 4 bytes less than total script size\n            addr := create(0, add(_script, 0x24), sub(mload(_script), 0x04))\n            switch iszero(extcodesize(addr))\n            case 1 { revert(0, 0) } // throw if contract failed to deploy\n        }\n    }\n}"
    },
    "@aragon/os/contracts/factory/EVMScriptRegistryFactory.sol": {
      "keccak256": "0x591ccf2f0ddfc70935e736bd0072b7319d07f29fa1d46a4f18231d6aa40781fa",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/factory/EVMScriptRegistryFactory.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../evmscript/EVMScriptRegistry.sol\";\n\nimport \"../evmscript/executors/CallsScript.sol\";\nimport \"../evmscript/executors/DelegateScript.sol\";\nimport \"../evmscript/executors/DeployDelegateScript.sol\";\n\nimport \"./AppProxyFactory.sol\";\nimport \"../kernel/Kernel.sol\";\nimport \"../acl/ACL.sol\";\n\n\ncontract EVMScriptRegistryFactory is AppProxyFactory, EVMScriptRegistryConstants {\n    address public baseReg;\n    address public baseCalls;\n    address public baseDel;\n    address public baseDeployDel;\n\n    function EVMScriptRegistryFactory() public {\n        baseReg = address(new EVMScriptRegistry());\n        baseCalls = address(new CallsScript());\n        baseDel = address(new DelegateScript());\n        baseDeployDel = address(new DeployDelegateScript());\n    }\n\n    function newEVMScriptRegistry(Kernel _dao, address _root) public returns (EVMScriptRegistry reg) {\n        reg = EVMScriptRegistry(_dao.newPinnedAppInstance(EVMSCRIPT_REGISTRY_APP_ID, baseReg));\n        reg.initialize();\n\n        ACL acl = ACL(_dao.acl());\n\n        _dao.setApp(_dao.APP_ADDR_NAMESPACE(), EVMSCRIPT_REGISTRY_APP_ID, reg);\n        acl.createPermission(this, reg, reg.REGISTRY_MANAGER_ROLE(), this);\n\n        reg.addScriptExecutor(baseCalls);     // spec 1 = CallsScript\n        reg.addScriptExecutor(baseDel);       // spec 2 = DelegateScript\n        reg.addScriptExecutor(baseDeployDel); // spec 3 = DeployDelegateScript\n\n        acl.revokePermission(this, reg, reg.REGISTRY_MANAGER_ROLE());\n        acl.setPermissionManager(_root, reg, reg.REGISTRY_MANAGER_ROLE());\n\n        return reg;\n    }\n}\n"
    },
    "@aragon/os/contracts/factory/DAOFactory.sol": {
      "keccak256": "0x60585270378bc1c725befb3449f4c48a744155bdf8fc659b7a72964247d36b78",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/factory/DAOFactory.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../kernel/Kernel.sol\";\nimport \"../kernel/KernelProxy.sol\";\n\nimport \"../acl/ACL.sol\";\n\nimport \"./EVMScriptRegistryFactory.sol\";\n\n\ncontract DAOFactory {\n    address public baseKernel;\n    address public baseACL;\n    EVMScriptRegistryFactory public regFactory;\n\n    event DeployDAO(address dao);\n    event DeployEVMScriptRegistry(address reg);\n\n    function DAOFactory(address _regFactory) public {\n        // No need to init as it cannot be killed by devops199\n        baseKernel = address(new Kernel());\n        baseACL = address(new ACL());\n\n        if (_regFactory != address(0)) {\n            regFactory = EVMScriptRegistryFactory(_regFactory);\n        }\n    }\n\n    /**\n    * @param _root Address that will be granted control to setup DAO permissions\n    */\n    function newDAO(address _root) public returns (Kernel dao) {\n        dao = Kernel(new KernelProxy(baseKernel));\n\n        address initialRoot = address(regFactory) != address(0) ? this : _root;\n        dao.initialize(baseACL, initialRoot);\n\n        ACL acl = ACL(dao.acl());\n\n        if (address(regFactory) != address(0)) {\n            bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n            bytes32 appManagerRole = dao.APP_MANAGER_ROLE();\n\n            acl.grantPermission(regFactory, acl, permRole);\n\n            acl.createPermission(regFactory, dao, appManagerRole, this);\n\n            EVMScriptRegistry reg = regFactory.newEVMScriptRegistry(dao, _root);\n            DeployEVMScriptRegistry(address(reg));\n\n            acl.revokePermission(regFactory, dao, appManagerRole);\n            acl.grantPermission(_root, acl, permRole);\n\n            acl.setPermissionManager(address(0), dao, appManagerRole);\n            acl.setPermissionManager(_root, acl, permRole);\n        }\n\n        DeployDAO(dao);\n    }\n}"
    },
    "giveth-common-contracts/contracts/ERC20.sol": {
      "keccak256": "0xcadd92ef9521600699043b047147e61718c62af07911731d77890dd47fc1a512",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/giveth-common-contracts/contracts/ERC20.sol"
      ],
      "content": "pragma solidity ^0.4.15;\n\n\n/**\n * @title ERC20\n * @dev A standard interface for tokens.\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n */\ncontract ERC20 {\n  \n    /// @dev Returns the total token supply\n    function totalSupply() public constant returns (uint256 supply);\n\n    /// @dev Returns the account balance of the account with address _owner\n    function balanceOf(address _owner) public constant returns (uint256 balance);\n\n    /// @dev Transfers _value number of tokens to address _to\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @dev Transfers _value number of tokens from address _from to address _to\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n"
    },
    "./contracts/EscapableApp.sol": {
      "keccak256": "0x03817336f5fa2d4211b9b5bb0beb6e5b2ad69061eb2b26e4e2d0bc04f486917a",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/EscapableApp.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n/*\n    Copyright 2016, Jordi Baylina\n    Contributor: Adri√† Massanet <adria@codecontext.io>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// import \"./Owned.sol\";\nimport \"giveth-common-contracts/contracts/ERC20.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\n\n/// @dev `EscapableApp` is a base level contract; it creates an escape hatch\n///  function that can be called in an\n///  emergency that will allow designated addresses to send any ether or tokens\n///  held in the contract to an `escapeHatchDestination` as long as they were\n///  not blacklisted\ncontract EscapableApp is AragonApp {\n    // warning whoever has this role can move all funds to the `escapeHatchDestination`\n    bytes32 constant public ESCAPE_HATCH_CALLER_ROLE = keccak256(\"ESCAPE_HATCH_CALLER_ROLE\");\n\n    event EscapeHatchBlackistedToken(address token);\n    event EscapeHatchCalled(address token, uint amount);\n\n    address public escapeHatchDestination;\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\n    uint[20] private storageOffset; // reserve 20 slots for future upgrades\n\n    function EscapableApp(address _escapeHatchDestination) public {\n        _init(_escapeHatchDestination);\n    }\n\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract; if a neutral address\n    ///  is required, the WHG Multisig is an option:\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n    function initialize(address _escapeHatchDestination) onlyInit public {\n        _init(_escapeHatchDestination);\n    }\n\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\n    /// security issue is uncovered or something unexpected happened\n    /// @param _token to transfer, use 0x0 for ether\n    function escapeHatch(address _token) external authP(ESCAPE_HATCH_CALLER_ROLE, arr(_token)) {\n        require(escapeBlacklist[_token]==false);\n\n        uint256 balance;\n\n        /// @dev Logic for ether\n        if (_token == 0x0) {\n            balance = this.balance;\n            escapeHatchDestination.transfer(balance);\n            EscapeHatchCalled(_token, balance);\n            return;\n        }\n        /// @dev Logic for tokens\n        ERC20 token = ERC20(_token);\n        balance = token.balanceOf(this);\n        require(token.transfer(escapeHatchDestination, balance));\n        EscapeHatchCalled(_token, balance);\n    }\n\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\n    /// @param _token the token address being queried\n    /// @return False if `_token` is in the blacklist and can't be taken out of\n    ///  the contract via the `escapeHatch()`\n    function isTokenEscapable(address _token) view external returns (bool) {\n        return !escapeBlacklist[_token];\n    }\n\n    function _init(address _escapeHatchDestination) internal {\n        initialized();\n        require(_escapeHatchDestination != 0x0);\n\n        escapeHatchDestination = _escapeHatchDestination;\n    }\n\n    /// @notice Creates the blacklist of tokens that are not able to be taken\n    ///  out of the contract; can only be done at the deployment, and the logic\n    ///  to add to the blacklist will be in the constructor of a child contract\n    /// @param _token the token contract address that is to be blacklisted \n    function _blacklistEscapeToken(address _token) internal {\n        escapeBlacklist[_token] = true;\n        EscapeHatchBlackistedToken(_token);\n    }\n}\n"
    },
    "./contracts/LiquidPledgingACLHelpers.sol": {
      "keccak256": "0xb675a7a788bf656d4c3c78f3b4cf6645afb432939d1a4c38d70e01d068b0ce62",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LiquidPledgingACLHelpers.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\ncontract LiquidPledgingACLHelpers {\n    function arr(uint64 a, uint64 b, address c, uint d, address e) internal pure returns(uint[] r) {\n        r = new uint[](4);\n        r[0] = uint(a);\n        r[1] = uint(b);\n        r[2] = uint(c);\n        r[3] = d;\n        r[4] = uint(e);\n    }\n\n    function arr(bool a) internal pure returns (uint[] r) {\n        r = new uint[](1);\n        uint _a;\n        assembly {\n            _a := a // forced casting\n        }\n        r[0] = _a;\n    }\n}"
    },
    "./contracts/LPVault.sol": {
      "keccak256": "0x1073bd4b8d127d13b4d9cc150f97bd87a5d6e6a9cf08e753b73758c8e8d54bda",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LPVault.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina\n    Contributors: RJ Ewing, Griff Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// @dev This contract holds ether securely for liquid pledging systems; for\n///  this iteration the funds will come often be escaped to the Giveth Multisig\n///  (safety precaution), but once fully tested and optimized this contract will\n///  be a safe place to store funds equipped with optional variable time delays\n///  to allow for an optional escapeHatch to be implemented in case of issues;\n///  future versions of this contract will be enabled for tokens\nimport \"./EscapableApp.sol\";\nimport \"./LiquidPledgingACLHelpers.sol\";\nimport \"giveth-common-contracts/contracts/ERC20.sol\";\n\n/// @dev `LiquidPledging` is a basic interface to allow the `LPVault` contract\n///  to confirm and cancel payments in the `LiquidPledging` contract.\ncontract ILiquidPledging {\n    function confirmPayment(uint64 idPledge, uint amount) public;\n    function cancelPayment(uint64 idPledge, uint amount) public;\n}\n\n/// @dev `LPVault` is a higher level contract built off of the `Escapable`\n///  contract that holds funds for the liquid pledging system.\ncontract LPVault is EscapableApp, LiquidPledgingACLHelpers {\n\n    bytes32 constant public CONFIRM_PAYMENT_ROLE = keccak256(\"CONFIRM_PAYMENT_ROLE\");\n    bytes32 constant public CANCEL_PAYMENT_ROLE = keccak256(\"CANCEL_PAYMENT_ROLE\");\n    bytes32 constant public SET_AUTOPAY_ROLE = keccak256(\"SET_AUTOPAY_ROLE\");\n\n    event AutoPaySet(bool autoPay);\n    event EscapeFundsCalled(address token, uint amount);\n    event ConfirmPayment(uint indexed idPayment, bytes32 indexed ref);\n    event CancelPayment(uint indexed idPayment, bytes32 indexed ref);\n    event AuthorizePayment(\n        uint indexed idPayment,\n        bytes32 indexed ref,\n        address indexed dest,\n        address token,\n        uint amount\n    );\n\n    enum PaymentStatus {\n        Pending, // When the payment is awaiting confirmation\n        Paid,    // When the payment has been sent\n        Canceled // When the payment will never be sent\n    }\n\n    /// @dev `Payment` is a public structure that describes the details of\n    ///  each payment the `ref` param makes it easy to track the movements of\n    ///  funds transparently by its connection to other `Payment` structs\n    struct Payment {\n        bytes32 ref; // an input that references details from other contracts\n        address dest; // recipient of the ETH\n        PaymentStatus state; // Pending, Paid or Canceled\n        address token;\n        uint amount; // amount of ETH (in wei) to be sent\n    }\n\n    bool public autoPay; // If false, payments will take 2 txs to be completed\n\n    // @dev An array that contains all the payments for this LPVault\n    Payment[] public payments;\n    ILiquidPledging public liquidPledging;\n\n    /// @dev The attached `LiquidPledging` contract is the only address that can\n    ///  call a function with this modifier\n    modifier onlyLiquidPledging() {\n        require(msg.sender == address(liquidPledging));\n        _;\n    }\n\n    function LPVault(address _escapeHatchDestination) EscapableApp(_escapeHatchDestination) public {\n    }\n\n    function initialize(address _escapeHatchDestination) onlyInit public {\n        require(false); // overload the EscapableApp\n        _escapeHatchDestination;\n    }\n\n    /// @param _liquidPledging \n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract; if a neutral address\n    ///  is required, the WHG Multisig is an option:\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n    function initialize(address _liquidPledging, address _escapeHatchDestination) onlyInit external {\n        super.initialize(_escapeHatchDestination);\n\n        require(_liquidPledging != 0x0);\n        liquidPledging = ILiquidPledging(_liquidPledging);\n    }\n\n    /// @notice Used to decentralize, toggles whether the LPVault will\n    ///  automatically confirm a payment after the payment has been authorized\n    /// @param _automatic If true, payments will confirm instantly, if false\n    ///  the training wheels are put on and the owner must manually approve \n    ///  every payment\n    function setAutopay(bool _automatic) external authP(SET_AUTOPAY_ROLE, arr(_automatic)) {\n        autoPay = _automatic;\n        AutoPaySet(autoPay);\n    }\n\n    /// @notice If `autoPay == true` the transfer happens automatically `else` the `owner`\n    ///  must call `confirmPayment()` for a transfer to occur (training wheels);\n    ///  either way, a new payment is added to `payments[]` \n    /// @param _ref References the payment will normally be the pledgeID\n    /// @param _dest The address that payments will be sent to\n    /// @param _amount The amount that the payment is being authorized for\n    /// @return idPayment The id of the payment (needed by the owner to confirm)\n    function authorizePayment(\n        bytes32 _ref,\n        address _dest,\n        address _token,\n        uint _amount\n    ) external onlyLiquidPledging returns (uint)\n    {\n        uint idPayment = payments.length;\n        payments.length ++;\n        payments[idPayment].state = PaymentStatus.Pending;\n        payments[idPayment].ref = _ref;\n        payments[idPayment].dest = _dest;\n        payments[idPayment].token = _token;\n        payments[idPayment].amount = _amount;\n\n        AuthorizePayment(idPayment, _ref, _dest, _token, _amount);\n\n        if (autoPay) {\n            _doConfirmPayment(idPayment);\n        }\n\n        return idPayment;\n    }\n\n    /// @notice Allows the owner to confirm payments;  since \n    ///  `authorizePayment` is the only way to populate the `payments[]` array\n    ///  this is generally used when `autopay` is `false` after a payment has\n    ///  has been authorized\n    /// @param _idPayment Array lookup for the payment.\n    function confirmPayment(uint _idPayment) public {\n        Payment storage p = payments[_idPayment];\n        require(canPerform(msg.sender, CONFIRM_PAYMENT_ROLE, arr(_idPayment, p.amount)));\n        _doConfirmPayment(_idPayment);\n    }\n\n    /// @notice When `autopay` is `false` and after a payment has been authorized\n    ///  to allow the owner to cancel a payment instead of confirming it.\n    /// @param _idPayment Array lookup for the payment.\n    function cancelPayment(uint _idPayment) external {\n        _doCancelPayment(_idPayment);\n    }\n\n    /// @notice `onlyOwner` An efficient way to confirm multiple payments\n    /// @param _idPayments An array of multiple payment ids\n    function multiConfirm(uint[] _idPayments) external {\n        for (uint i = 0; i < _idPayments.length; i++) {\n            confirmPayment(_idPayments[i]);\n        }\n    }\n\n    /// @notice `onlyOwner` An efficient way to cancel multiple payments\n    /// @param _idPayments An array of multiple payment ids\n    function multiCancel(uint[] _idPayments) external {\n        for (uint i = 0; i < _idPayments.length; i++) {\n            _doCancelPayment(_idPayments[i]);\n        }\n    }\n\n    /// Transfer tokens to the escapeHatchDestination.\n    /// Used as a safety mechanism to prevent the vault from holding too much value\n    /// before being thoroughly battle-tested.\n    /// @param _token to transfer\n    /// @param _amount to transfer\n    function escapeFunds(address _token, uint _amount) external authP(ESCAPE_HATCH_CALLER_ROLE, arr(_token)) {\n        require(_token != 0x0);\n        ERC20 token = ERC20(_token);\n        require(token.transfer(escapeHatchDestination, _amount));\n        EscapeFundsCalled(_token, _amount);\n    }\n\n    /// @return The total number of payments that have ever been authorized\n    function nPayments() external view returns (uint) {\n        return payments.length;\n    }\n\n    /// @notice Transfers ETH according to the data held within the specified\n    ///  payment id (internal function)\n    /// @param _idPayment id number for the payment about to be fulfilled \n    function _doConfirmPayment(uint _idPayment) internal {\n        require(_idPayment < payments.length);\n        Payment storage p = payments[_idPayment];\n        require(p.state == PaymentStatus.Pending);\n\n        p.state = PaymentStatus.Paid;\n        liquidPledging.confirmPayment(uint64(p.ref), p.amount);\n\n        ERC20 token = ERC20(p.token);\n        require(token.transfer(p.dest, p.amount)); // Transfers token to dest\n\n        ConfirmPayment(_idPayment, p.ref);\n    }\n\n    /// @notice Cancels a pending payment (internal function)\n    /// @param _idPayment id number for the payment    \n    function _doCancelPayment(uint _idPayment) internal authP(CANCEL_PAYMENT_ROLE, arr(_idPayment)) {\n        require(_idPayment < payments.length);\n        Payment storage p = payments[_idPayment];\n        require(p.state == PaymentStatus.Pending);\n\n        p.state = PaymentStatus.Canceled;\n\n        liquidPledging.cancelPayment(uint64(p.ref), p.amount);\n\n        CancelPayment(_idPayment, p.ref);\n    }\n}\n"
    },
    "./contracts/LiquidPledgingStorage.sol": {
      "keccak256": "0x81ef504efbc50c58acec1b85784d9be3cb0bd761b3e9d013b19aa5f0d5169a08",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LiquidPledgingStorage.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./ILiquidPledgingPlugin.sol\";\n\n/// @dev This is an interface for `LPVault` which serves as a secure storage for\n///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes\n///  payments can Pledges be converted for ETH\ninterface ILPVault {\n    function authorizePayment(bytes32 _ref, address _dest, address _token, uint _amount) public;\n}\n\n/// This contract contains all state variables used in LiquidPledging contracts\n/// This is done to have everything in 1 location, b/c state variable layout\n/// is MUST have be the same when performing an upgrade.\ncontract LiquidPledgingStorage {\n    enum PledgeAdminType { Giver, Delegate, Project }\n    enum PledgeState { Pledged, Paying, Paid }\n\n    /// @dev This struct defines the details of a `PledgeAdmin` which are \n    ///  commonly referenced by their index in the `admins` array\n    ///  and can own pledges and act as delegates\n    struct PledgeAdmin { \n        PledgeAdminType adminType; // Giver, Delegate or Project\n        address addr; // Account or contract address for admin\n        uint64 commitTime;  // In seconds, used for time Givers' & Delegates' have to veto\n        uint64 parentProject;  // Only for projects\n        bool canceled;      //Always false except for canceled projects\n\n        /// @dev if the plugin is 0x0 then nothing happens, if its an address\n        // than that smart contract is called when appropriate\n        ILiquidPledgingPlugin plugin; \n        string name;\n        string url;  // Can be IPFS hash\n    }\n\n    struct Pledge {\n        uint amount;\n        uint64[] delegationChain; // List of delegates in order of authority\n        uint64 owner; // PledgeAdmin\n        uint64 intendedProject; // Used when delegates are sending to projects\n        uint64 commitTime;  // When the intendedProject will become the owner\n        uint64 oldPledge; // Points to the id that this Pledge was derived from\n        address token;\n        PledgeState pledgeState; //  Pledged, Paying, Paid\n    }\n\n    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin\n    Pledge[] pledges;\n    /// @dev this mapping allows you to search for a specific pledge's \n    ///  index number by the hash of that pledge\n    mapping (bytes32 => uint64) hPledge2idx;\n\n    // this whitelist is for non-proxied plugins\n    mapping (bytes32 => bool) pluginContractWhitelist;\n    // this whitelist is for proxied plugins\n    mapping (address => bool) pluginInstanceWhitelist;\n    bool public whitelistDisabled = false;\n\n    ILPVault public vault;\n\n    // reserve 50 slots for future upgrades. I'm not sure if this is necessary \n    // but b/c of multiple inheritance used in lp, better safe then sorry.\n    // especially since it is free\n    uint[50] private storageOffset;\n}"
    },
    "./contracts/LiquidPledgingPlugins.sol": {
      "keccak256": "0xb3566dfb5a8a1a0a57952501f6ddc39974fff2ee4c2861b20342a95b442cc776",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LiquidPledgingPlugins.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"./LiquidPledgingStorage.sol\";\nimport \"./LiquidPledgingACLHelpers.sol\";\n\ncontract LiquidPledgingPlugins is AragonApp, LiquidPledgingStorage, LiquidPledgingACLHelpers {\n\n    bytes32 constant public PLUGIN_MANAGER_ROLE = keccak256(\"PLUGIN_MANAGER_ROLE\");\n\n    function addValidPluginInstance(address addr) auth(PLUGIN_MANAGER_ROLE) external {\n        pluginInstanceWhitelist[addr] = true;\n    }\n\n    function addValidPluginContract(bytes32 contractHash) auth(PLUGIN_MANAGER_ROLE) public {\n        pluginContractWhitelist[contractHash] = true;\n    }\n\n    function addValidPluginContracts(bytes32[] contractHashes) external auth(PLUGIN_MANAGER_ROLE) {\n        for (uint8 i = 0; i < contractHashes.length; i++) {\n            addValidPluginContract(contractHashes[i]);\n        }\n    }\n\n    function removeValidPluginContract(bytes32 contractHash) external authP(PLUGIN_MANAGER_ROLE, arr(contractHash)) {\n        pluginContractWhitelist[contractHash] = false;\n    }\n\n    function removeValidPluginInstance(address addr) external authP(PLUGIN_MANAGER_ROLE, arr(addr)) {\n        pluginInstanceWhitelist[addr] = false;\n    }\n\n    function useWhitelist(bool useWhitelist) external auth(PLUGIN_MANAGER_ROLE) {\n        whitelistDisabled = !useWhitelist;\n    }\n\n    function isValidPlugin(address addr) public view returns(bool) {\n        if (whitelistDisabled || addr == 0x0) {\n            return true;\n        }\n\n        // first check pluginInstances\n        if (pluginInstanceWhitelist[addr]) {\n            return true;\n        }\n\n        // if the addr isn't a valid instance, check the contract code\n        bytes32 contractHash = getCodeHash(addr);\n\n        return pluginContractWhitelist[contractHash];\n    }\n\n    function getCodeHash(address addr) public view returns(bytes32) {\n        bytes memory o_code;\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(addr)\n            // allocate output byte array - this could also be done without assembly\n            // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n            mstore(o_code, size) // store length in memory\n            // actually retrieve the code, this needs assembly\n            extcodecopy(addr, add(o_code, 0x20), 0, size)\n        }\n        return keccak256(o_code);\n    }\n}"
    },
    "./contracts/PledgeAdmins.sol": {
      "keccak256": "0xfa7101ced06daaf446ff10e222aafb68a0d52dca99f57d6c8d7aab959e6a5104",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/PledgeAdmins.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport \"./LiquidPledgingPlugins.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\ncontract PledgeAdmins is AragonApp, LiquidPledgingPlugins {\n\n    // Limits inserted to prevent large loops that could prevent canceling\n    uint constant MAX_SUBPROJECT_LEVEL = 20;\n    uint constant MAX_INTERPROJECT_LEVEL = 20;\n\n    // Events\n    event GiverAdded(uint64 indexed idGiver, string url);\n    event GiverUpdated(uint64 indexed idGiver, string url);\n    event DelegateAdded(uint64 indexed idDelegate, string url);\n    event DelegateUpdated(uint64 indexed idDelegate, string url);\n    event ProjectAdded(uint64 indexed idProject, string url);\n    event ProjectUpdated(uint64 indexed idProject, string url);\n\n////////////////////\n// Public functions\n////////////////////\n\n    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address\n    /// @param name The name used to identify the Giver\n    /// @param url The link to the Giver's profile often an IPFS hash\n    /// @param commitTime The length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    /// @param plugin This is Giver's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idGiver The id number used to reference this Admin\n    function addGiver(\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idGiver)\n    {\n        return addGiver(\n            msg.sender,\n            name,\n            url,\n            commitTime,\n            plugin\n        );\n    }\n\n    // TODO: is there an issue w/ allowing anyone to create a giver on behalf of another addy?\n    function addGiver(\n        address addr,\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) public returns (uint64 idGiver)\n    {\n        require(isValidPlugin(plugin)); // Plugin check\n\n        idGiver = uint64(admins.length);\n\n        // Save the fields\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Giver,\n                addr,\n                commitTime,\n                0,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        GiverAdded(idGiver, url);\n    }\n\n    /// @notice Updates a Giver's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\n    ///  by the current address of the Giver\n    /// @param idGiver This is the Admin id number used to specify the Giver\n    /// @param newAddr The new address that represents this Giver\n    /// @param newName The new name used to identify the Giver\n    /// @param newUrl The new link to the Giver's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    function updateGiver(\n        uint64 idGiver,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage giver = _findAdmin(idGiver);\n        require(msg.sender == giver.addr);\n        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver\n        giver.addr = newAddr;\n        giver.name = newName;\n        giver.url = newUrl;\n        giver.commitTime = newCommitTime;\n\n        GiverUpdated(idGiver, newUrl);\n    }\n\n    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr\n    /// @param name The name used to identify the Delegate\n    /// @param url The link to the Delegate's profile often an IPFS hash\n    /// @param commitTime Sets the length of time in seconds that this delegate\n    ///  can be vetoed. Whenever this delegate is in a delegate chain the time\n    ///  allowed to veto any event must be greater than or equal to this time.\n    /// @param plugin This is Delegate's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idxDelegate The id number used to reference this Delegate within\n    ///  the PLEDGE_ADMIN array\n    function addDelegate(\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idDelegate) \n    {\n        require(isValidPlugin(plugin)); // Plugin check\n\n        idDelegate = uint64(admins.length);\n\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Delegate,\n                msg.sender,\n                commitTime,\n                0,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        DelegateAdded(idDelegate, url);\n    }\n\n    /// @notice Updates a Delegate's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\n    ///  by the current address of the Delegate\n    /// @param idDelegate The Admin id number used to specify the Delegate\n    /// @param newAddr The new address that represents this Delegate\n    /// @param newName The new name used to identify the Delegate\n    /// @param newUrl The new link to the Delegate's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds that this\n    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain\n    ///  the time allowed to veto any event must be greater than or equal to\n    ///  this time.\n    function updateDelegate(\n        uint64 idDelegate,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage delegate = _findAdmin(idDelegate);\n        require(msg.sender == delegate.addr);\n        require(delegate.adminType == PledgeAdminType.Delegate);\n        delegate.addr = newAddr;\n        delegate.name = newName;\n        delegate.url = newUrl;\n        delegate.commitTime = newCommitTime;\n\n        DelegateUpdated(idDelegate, newUrl);\n    }\n\n    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr\n    /// @param name The name used to identify the Project\n    /// @param url The link to the Project's profile often an IPFS hash\n    /// @param projectAdmin The address for the trusted project manager\n    /// @param parentProject The Admin id number for the parent project or 0 if\n    ///  there is no parentProject\n    /// @param commitTime Sets the length of time in seconds the Project has to\n    ///   veto when the Project delegates to another Delegate and they pledge\n    ///   those funds to a project\n    /// @param plugin This is Project's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idProject The id number used to reference this Admin\n    function addProject(\n        string name,\n        string url,\n        address projectAdmin,\n        uint64 parentProject,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idProject) \n    {\n        require(isValidPlugin(plugin));\n\n        if (parentProject != 0) {\n            PledgeAdmin storage a = _findAdmin(parentProject);\n            // getProjectLevel will check that parentProject has a `Project` adminType\n            require(_getProjectLevel(a) < MAX_SUBPROJECT_LEVEL);\n        }\n\n        idProject = uint64(admins.length);\n\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Project,\n                projectAdmin,\n                commitTime,\n                parentProject,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        ProjectAdded(idProject, url);\n    }\n\n    /// @notice Updates a Project's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin or a parentProject,\n    ///  and it must be called by the current address of the Project\n    /// @param idProject The Admin id number used to specify the Project\n    /// @param newAddr The new address that represents this Project\n    /// @param newName The new name used to identify the Project\n    /// @param newUrl The new link to the Project's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds the Project has\n    ///  to veto when the Project delegates to a Delegate and they pledge those\n    ///  funds to a project\n    function updateProject(\n        uint64 idProject,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage project = _findAdmin(idProject);\n\n        require(msg.sender == project.addr);\n        require(project.adminType == PledgeAdminType.Project);\n\n        project.addr = newAddr;\n        project.name = newName;\n        project.url = newUrl;\n        project.commitTime = newCommitTime;\n\n        ProjectUpdated(idProject, newUrl);\n    }\n\n/////////////////////////////\n// Public constant functions\n/////////////////////////////\n\n    /// @notice A constant getter used to check how many total Admins exist\n    /// @return The total number of admins (Givers, Delegates and Projects) .\n    function numberOfPledgeAdmins() external view returns(uint) {\n        return admins.length - 1;\n    }\n\n    /// @notice A constant getter to check the details of a specified Admin\n    /// @return addr Account or contract address for admin\n    /// @return name Name of the pledgeAdmin\n    /// @return url The link to the Project's profile often an IPFS hash\n    /// @return commitTime The length of time in seconds the Admin has to veto\n    ///   when the Admin delegates to a Delegate and that Delegate pledges those\n    ///   funds to a project\n    /// @return parentProject The Admin id number for the parent project or 0\n    ///  if there is no parentProject\n    /// @return canceled 0 for Delegates & Givers, true if a Project has been\n    ///  canceled\n    /// @return plugin This is Project's liquidPledging plugin allowing for\n    ///  extended functionality\n    function getPledgeAdmin(uint64 idAdmin) external view returns (\n        PledgeAdminType adminType,\n        address addr,\n        string name,\n        string url,\n        uint64 commitTime,\n        uint64 parentProject,\n        bool canceled,\n        address plugin\n    ) {\n        PledgeAdmin storage a = _findAdmin(idAdmin);\n        adminType = a.adminType;\n        addr = a.addr;\n        name = a.name;\n        url = a.url;\n        commitTime = a.commitTime;\n        parentProject = a.parentProject;\n        canceled = a.canceled;\n        plugin = address(a.plugin);\n    }\n\n    /// @notice A getter to find if a specified Project has been canceled\n    /// @param projectId The Admin id number used to specify the Project\n    /// @return True if the Project has been canceled\n    function isProjectCanceled(uint64 projectId)\n        public view returns (bool)\n    {\n        PledgeAdmin storage a = _findAdmin(projectId);\n\n        if (a.adminType == PledgeAdminType.Giver) {\n            return false;\n        }\n\n        assert(a.adminType == PledgeAdminType.Project);\n\n        if (a.canceled) {\n            return true;\n        }\n        if (a.parentProject == 0) {\n            return false;\n        }\n\n        return isProjectCanceled(a.parentProject);\n    }\n\n///////////////////\n// Internal methods\n///////////////////\n\n    /// @notice A getter to look up a Admin's details\n    /// @param idAdmin The id for the Admin to lookup\n    /// @return The PledgeAdmin struct for the specified Admin\n    function _findAdmin(uint64 idAdmin) internal view returns (PledgeAdmin storage) {\n        require(idAdmin < admins.length);\n        return admins[idAdmin];\n    }\n\n    /// @notice Find the level of authority a specific Project has\n    ///  using a recursive loop\n    /// @param a The project admin being queried\n    /// @return The level of authority a specific Project has\n    function _getProjectLevel(PledgeAdmin a) internal view returns(uint64) {\n        assert(a.adminType == PledgeAdminType.Project);\n\n        if (a.parentProject == 0) {\n            return(1);\n        }\n\n        PledgeAdmin storage parent = _findAdmin(a.parentProject);\n        return _getProjectLevel(parent) + 1;\n    }\n}"
    },
    "./contracts/Pledges.sol": {
      "keccak256": "0x9c7a60dff92f94d518d0c4a40d5434cd23680f79fd364ae855575ae4ca683797",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/Pledges.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"./LiquidPledgingStorage.sol\";\n\ncontract Pledges is AragonApp, LiquidPledgingStorage {\n\n    // Limits inserted to prevent large loops that could prevent canceling\n    uint constant MAX_DELEGATES = 10;\n\n    // a constant for when a delegate is requested that is not in the system\n    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;\n\n/////////////////////////////\n// Public constant functions\n////////////////////////////\n\n    /// @notice A constant getter that returns the total number of pledges\n    /// @return The total number of Pledges in the system\n    function numberOfPledges() external view returns (uint) {\n        return pledges.length - 1;\n    }\n\n    /// @notice A getter that returns the details of the specified pledge\n    /// @param idPledge the id number of the pledge being queried\n    /// @return the amount, owner, the number of delegates (but not the actual\n    ///  delegates, the intendedProject (if any), the current commit time and\n    ///  the previous pledge this pledge was derived from\n    function getPledge(uint64 idPledge) external view returns(\n        uint amount,\n        uint64 owner,\n        uint64 nDelegates,\n        uint64 intendedProject,\n        uint64 commitTime,\n        uint64 oldPledge,\n        address token,\n        PledgeState pledgeState\n    ) {\n        Pledge memory p = _findPledge(idPledge);\n        amount = p.amount;\n        owner = p.owner;\n        nDelegates = uint64(p.delegationChain.length);\n        intendedProject = p.intendedProject;\n        commitTime = p.commitTime;\n        oldPledge = p.oldPledge;\n        token = p.token;\n        pledgeState = p.pledgeState;\n    }\n\n\n////////////////////\n// Internal methods\n////////////////////\n\n    /// @notice This creates a Pledge with an initial amount of 0 if one is not\n    ///  created already; otherwise it finds the pledge with the specified\n    ///  attributes; all pledges technically exist, if the pledge hasn't been\n    ///  created in this system yet it simply isn't in the hash array\n    ///  hPledge2idx[] yet\n    /// @param owner The owner of the pledge being looked up\n    /// @param delegationChain The list of delegates in order of authority\n    /// @param intendedProject The project this pledge will Fund after the\n    ///  commitTime has passed\n    /// @param commitTime The length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    /// @param oldPledge This value is used to store the pledge the current\n    ///  pledge was came from, and in the case a Project is canceled, the Pledge\n    ///  will revert back to it's previous state\n    /// @param state The pledge state: Pledged, Paying, or state\n    /// @return The hPledge2idx index number\n    function _findOrCreatePledge(\n        uint64 owner,\n        uint64[] delegationChain,\n        uint64 intendedProject,\n        uint64 commitTime,\n        uint64 oldPledge,\n        address token,\n        PledgeState state\n    ) internal returns (uint64)\n    {\n        bytes32 hPledge = keccak256(delegationChain, owner, intendedProject, commitTime, oldPledge, token, state);\n        uint64 id = hPledge2idx[hPledge];\n        if (id > 0) {\n            return id;\n        }\n\n        id = uint64(pledges.length);\n        hPledge2idx[hPledge] = id;\n        pledges.push(\n            Pledge(\n                0,\n                delegationChain,\n                owner,\n                intendedProject,\n                commitTime,\n                oldPledge,\n                token,\n                state\n            )\n        );\n        return id;\n    }\n\n    /// @param idPledge the id of the pledge to load from storage\n    /// @return The Pledge\n    function _findPledge(uint64 idPledge) internal view returns(Pledge storage) {\n        require(idPledge < pledges.length);\n        return pledges[idPledge];\n    }\n\n    /// @notice A getter that searches the delegationChain for the level of\n    ///  authority a specific delegate has within a Pledge\n    /// @param p The Pledge that will be searched\n    /// @param idDelegate The specified delegate that's searched for\n    /// @return If the delegate chain contains the delegate with the\n    ///  `admins` array index `idDelegate` this returns that delegates\n    ///  corresponding index in the delegationChain. Otherwise it returns\n    ///  the NOTFOUND constant\n    function _getDelegateIdx(Pledge p, uint64 idDelegate) internal pure returns(uint64) {\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            if (p.delegationChain[i] == idDelegate) {\n                return uint64(i);\n            }\n        }\n        return NOTFOUND;\n    }\n\n    /// @notice A getter to find how many old \"parent\" pledges a specific Pledge\n    ///  had using a self-referential loop\n    /// @param p The Pledge being queried\n    /// @return The number of old \"parent\" pledges a specific Pledge had\n    function _getPledgeLevel(Pledge p) internal view returns(uint) {\n        if (p.oldPledge == 0) {\n            return 0;\n        }\n        Pledge storage oldP = _findPledge(p.oldPledge);\n        return _getPledgeLevel(oldP) + 1; // a loop lookup\n    }\n}\n"
    },
    "./contracts/LiquidPledgingBase.sol": {
      "keccak256": "0xc6bfc0886e82d9896a4aac941fc666536dc3f6e28f0a2f2ef486a1e12fce0aa5",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LiquidPledgingBase.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina\n    Contributors: Adri√† Massanet <adria@codecontext.io>, RJ Ewing, Griff\n    Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledgingStorage.sol\";\nimport \"./PledgeAdmins.sol\";\nimport \"./Pledges.sol\";\nimport \"./EscapableApp.sol\";\n\n/// @dev `LiquidPledgingBase` is the base level contract used to carry out\n///  liquidPledging's most basic functions, mostly handling and searching the\n///  data structures\ncontract LiquidPledgingBase is EscapableApp, LiquidPledgingStorage, PledgeAdmins, Pledges {\n\n    event Transfer(uint indexed from, uint indexed to, uint amount);\n    event CancelProject(uint indexed idProject);\n\n/////////////\n// Modifiers\n/////////////\n\n    /// @dev The `vault`is the only addresses that can call a function with this\n    ///  modifier\n    modifier onlyVault() {\n        require(msg.sender == address(vault));\n        _;\n    }\n\n///////////////\n// Constructor\n///////////////\n\n    function initialize(address _escapeHatchDestination) onlyInit public {\n        require(false); // overload the EscapableApp\n        _escapeHatchDestination;\n    }\n\n    /// @param _vault The vault where the ETH backing the pledges is stored\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract; if a neutral address\n    ///  is required, the WHG Multisig is an option:\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n    function initialize(address _vault, address _escapeHatchDestination) onlyInit public {\n        super.initialize(_escapeHatchDestination);\n        require(_vault != 0x0);\n\n        vault = ILPVault(_vault);\n\n        admins.length = 1; // we reserve the 0 admin\n        pledges.length = 1; // we reserve the 0 pledge\n    }\n\n\n/////////////////////////////\n// Public constant functions\n/////////////////////////////\n\n    /// @notice Getter to find Delegate w/ the Pledge ID & the Delegate index\n    /// @param idPledge The id number representing the pledge being queried\n    /// @param idxDelegate The index number for the delegate in this Pledge \n    function getPledgeDelegate(uint64 idPledge, uint64 idxDelegate) external view returns(\n        uint64 idDelegate,\n        address addr,\n        string name\n    ) {\n        Pledge storage p = _findPledge(idPledge);\n        idDelegate = p.delegationChain[idxDelegate - 1];\n        PledgeAdmin storage delegate = _findAdmin(idDelegate);\n        addr = delegate.addr;\n        name = delegate.name;\n    }\n\n///////////////////\n// Public functions\n///////////////////\n\n    /// @notice Only affects pledges with the Pledged PledgeState for 2 things:\n    ///   #1: Checks if the pledge should be committed. This means that\n    ///       if the pledge has an intendedProject and it is past the\n    ///       commitTime, it changes the owner to be the proposed project\n    ///       (The UI will have to read the commit time and manually do what\n    ///       this function does to the pledge for the end user\n    ///       at the expiration of the commitTime)\n    ///\n    ///   #2: Checks to make sure that if there has been a cancellation in the\n    ///       chain of projects, the pledge's owner has been changed\n    ///       appropriately.\n    ///\n    /// This function can be called by anybody at anytime on any pledge.\n    ///  In general it can be called to force the calls of the affected \n    ///  plugins, which also need to be predicted by the UI\n    /// @param idPledge This is the id of the pledge that will be normalized\n    /// @return The normalized Pledge!\n    function normalizePledge(uint64 idPledge) public returns(uint64) {\n        Pledge storage p = _findPledge(idPledge);\n\n        // Check to make sure this pledge hasn't already been used \n        // or is in the process of being used\n        if (p.pledgeState != PledgeState.Pledged) {\n            return idPledge;\n        }\n\n        // First send to a project if it's proposed and committed\n        if ((p.intendedProject > 0) && ( _getTime() > p.commitTime)) {\n            uint64 oldPledge = _findOrCreatePledge(\n                p.owner,\n                p.delegationChain,\n                0,\n                0,\n                p.oldPledge,\n                p.token,\n                PledgeState.Pledged\n            );\n            uint64 toPledge = _findOrCreatePledge(\n                p.intendedProject,\n                new uint64[](0),\n                0,\n                0,\n                oldPledge,\n                p.token,\n                PledgeState.Pledged\n            );\n            _doTransfer(idPledge, toPledge, p.amount);\n            idPledge = toPledge;\n            p = _findPledge(idPledge);\n        }\n\n        toPledge = _getOldestPledgeNotCanceled(idPledge);\n        if (toPledge != idPledge) {\n            _doTransfer(idPledge, toPledge, p.amount);\n        }\n\n        return toPledge;\n    }\n\n////////////////////\n// Internal methods\n////////////////////\n\n    /// @notice A check to see if the msg.sender is the owner or the\n    ///  plugin contract for a specific Admin\n    /// @param idAdmin The id of the admin being checked\n    function _checkAdminOwner(uint64 idAdmin) internal view {\n        PledgeAdmin storage a = _findAdmin(idAdmin);\n        require(msg.sender == address(a.plugin) || msg.sender == a.addr);\n    }\n\n    function _transfer( \n        uint64 idSender,\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal\n    {\n        require(idReceiver > 0); // prevent burning value\n        idPledge = normalizePledge(idPledge);\n\n        Pledge storage p = _findPledge(idPledge);\n        PledgeAdmin storage receiver = _findAdmin(idReceiver);\n\n        require(p.pledgeState == PledgeState.Pledged);\n\n        // If the sender is the owner of the Pledge\n        if (p.owner == idSender) {\n\n            if (receiver.adminType == PledgeAdminType.Giver) {\n                _transferOwnershipToGiver(idPledge, amount, idReceiver);\n                return;\n            } else if (receiver.adminType == PledgeAdminType.Project) {\n                _transferOwnershipToProject(idPledge, amount, idReceiver);\n                return;\n            } else if (receiver.adminType == PledgeAdminType.Delegate) {\n\n                uint recieverDIdx = _getDelegateIdx(p, idReceiver);\n                if (p.intendedProject > 0 && recieverDIdx != NOTFOUND) {\n                    // if there is an intendedProject and the receiver is in the delegationChain,\n                    // then we want to preserve the delegationChain as this is a veto of the\n                    // intendedProject by the owner\n\n                    if (recieverDIdx == p.delegationChain.length - 1) {\n                        uint64 toPledge = _findOrCreatePledge(\n                            p.owner,\n                            p.delegationChain,\n                            0,\n                            0,\n                            p.oldPledge,\n                            p.token,\n                            PledgeState.Pledged);\n                        _doTransfer(idPledge, toPledge, amount);\n                        return;\n                    }\n\n                    _undelegate(idPledge, amount, p.delegationChain.length - receiverDIdx - 1);\n                    return;\n                }\n                // owner is not vetoing an intendedProject and is transferring the pledge to a delegate,\n                // so we want to reset the delegationChain\n                idPledge = _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length\n                );\n                _appendDelegate(idPledge, amount, idReceiver);\n                return;\n            }\n\n            // This should never be reached as the receiver.adminType\n            // should always be either a Giver, Project, or Delegate\n            assert(false);\n        }\n\n        // If the sender is a Delegate\n        uint senderDIdx = _getDelegateIdx(p, idSender);\n        if (senderDIdx != NOTFOUND) {\n\n            // And the receiver is another Giver\n            if (receiver.adminType == PledgeAdminType.Giver) {\n                // Only transfer to the Giver who owns the pledge\n                assert(p.owner == idReceiver);\n                _undelegate(idPledge, amount, p.delegationChain.length);\n                return;\n            }\n\n            // And the receiver is another Delegate\n            if (receiver.adminType == PledgeAdminType.Delegate) {\n                uint receiverDIdx = _getDelegateIdx(p, idReceiver);\n\n                // And not in the delegationChain\n                if (receiverDIdx == NOTFOUND) {\n                    idPledge = _undelegate(\n                        idPledge,\n                        amount,\n                        p.delegationChain.length - senderDIdx - 1\n                    );\n                    _appendDelegate(idPledge, amount, idReceiver);\n                    return;\n\n                // And part of the delegationChain and is after the sender, then\n                //  all of the other delegates after the sender are removed and\n                //  the receiver is appended at the end of the delegationChain\n                } else if (receiverDIdx > senderDIdx) {\n                    idPledge = _undelegate(\n                        idPledge,\n                        amount,\n                        p.delegationChain.length - senderDIdx - 1\n                    );\n                    _appendDelegate(idPledge, amount, idReceiver);\n                    return;\n                }\n\n                // And is already part of the delegate chain but is before the\n                //  sender, then the sender and all of the other delegates after\n                //  the RECEIVER are removed from the delegationChain\n                //TODO Check for Game Theory issues (from Arthur) this allows the sender to sort of go komakosi and remove himself and the delegates between himself and the receiver... should this authority be allowed?\n                _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length - receiverDIdx - 1\n                );\n                return;\n            }\n\n            // And the receiver is a Project, all the delegates after the sender\n            //  are removed and the amount is pre-committed to the project\n            if (receiver.adminType == PledgeAdminType.Project) {\n                idPledge = _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length - senderDIdx - 1\n                );\n                _proposeAssignProject(idPledge, amount, idReceiver);\n                return;\n            }\n        }\n        assert(false);  // When the sender is not an owner or a delegate\n    }\n\n    /// @notice `transferOwnershipToProject` allows for the transfer of\n    ///  ownership to the project, but it can also be called by a project\n    ///  to un-delegate everyone by setting one's own id for the idReceiver\n    /// @param idPledge the id of the pledge to be transfered.\n    /// @param amount Quantity of value that's being transfered\n    /// @param idReceiver The new owner of the project (or self to un-delegate)\n    function _transferOwnershipToProject(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        // Ensure that the pledge is not already at max pledge depth\n        // and the project has not been canceled\n        require(_getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n        require(!isProjectCanceled(idReceiver));\n\n        uint64 oldPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        uint64 toPledge = _findOrCreatePledge(\n            idReceiver,                     // Set the new owner\n            new uint64[](0),                // clear the delegation chain\n            0,\n            0,\n            oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }   \n\n\n    /// @notice `transferOwnershipToGiver` allows for the transfer of\n    ///  value back to the Giver, value is placed in a pledged state\n    ///  without being attached to a project, delegation chain, or time line.\n    /// @param idPledge the id of the pledge to be transferred.\n    /// @param amount Quantity of value that's being transferred\n    /// @param idReceiver The new owner of the pledge\n    function _transferOwnershipToGiver(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        uint64 toPledge = _findOrCreatePledge(\n            idReceiver,\n            new uint64[](0),\n            0,\n            0,\n            0,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\n    ///  end of the delegate chain for a given Pledge.\n    /// @param idPledge the id of the pledge thats delegate chain will be modified.\n    /// @param amount Quantity of value that's being chained.\n    /// @param idReceiver The delegate to be added at the end of the chain\n    function _appendDelegate(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.delegationChain.length < MAX_DELEGATES);\n        uint64[] memory newDelegationChain = new uint64[](\n            p.delegationChain.length + 1\n        );\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            newDelegationChain[i] = p.delegationChain[i];\n        }\n\n        // Make the last item in the array the idReceiver\n        newDelegationChain[p.delegationChain.length] = idReceiver;\n\n        uint64 toPledge = _findOrCreatePledge(\n            p.owner,\n            newDelegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\n    ///  end of the delegate chain for a given Pledge.\n    /// @param idPledge the id of the pledge thats delegate chain will be modified.\n    /// @param amount Quantity of value that's shifted from delegates.\n    /// @param q Number (or depth) of delegates to remove\n    /// @return toPledge The id for the pledge being adjusted or created\n    function _undelegate(\n        uint64 idPledge,\n        uint amount,\n        uint q\n    ) internal returns (uint64 toPledge)\n    {\n        Pledge storage p = _findPledge(idPledge);\n        uint64[] memory newDelegationChain = new uint64[](\n            p.delegationChain.length - q\n        );\n\n        for (uint i = 0; i < p.delegationChain.length - q; i++) {\n            newDelegationChain[i] = p.delegationChain[i];\n        }\n        toPledge = _findOrCreatePledge(\n            p.owner,\n            newDelegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `proposeAssignProject` proposes the assignment of a pledge\n    ///  to a specific project.\n    /// @dev This function should potentially be named more specifically.\n    /// @param idPledge the id of the pledge that will be assigned.\n    /// @param amount Quantity of value this pledge leader would be assigned.\n    /// @param idReceiver The project this pledge will potentially \n    ///  be assigned to.\n    function _proposeAssignProject(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(_getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n        require(!isProjectCanceled(idReceiver));\n\n        uint64 toPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            idReceiver,\n            uint64(_getTime() + _maxCommitTime(p)),\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `doTransfer` is designed to allow for pledge amounts to be \n    ///  shifted around internally.\n    /// @param from This is the id of the pledge from which value will be transferred.\n    /// @param to This is the id of the pledge that value will be transferred to.\n    /// @param _amount The amount of value that will be transferred.\n    function _doTransfer(uint64 from, uint64 to, uint _amount) internal {\n        uint amount = _callPlugins(true, from, to, _amount);\n        if (from == to) {\n            return;\n        }\n        if (amount == 0) {\n            return;\n        }\n\n        Pledge storage pFrom = _findPledge(from);\n        Pledge storage pTo = _findPledge(to);\n\n        require(pFrom.amount >= amount);\n        pFrom.amount -= amount;\n        pTo.amount += amount;\n\n        Transfer(from, to, amount);\n        _callPlugins(false, from, to, amount);\n    }\n\n    /// @notice A getter to find the longest commitTime out of the owner and all\n    ///  the delegates for a specified pledge\n    /// @param p The Pledge being queried\n    /// @return The maximum commitTime out of the owner and all the delegates\n    function _maxCommitTime(Pledge p) internal view returns(uint64 commitTime) {\n        PledgeAdmin storage a = _findAdmin(p.owner);\n        commitTime = a.commitTime; // start with the owner's commitTime\n\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            a = _findAdmin(p.delegationChain[i]);\n\n            // If a delegate's commitTime is longer, make it the new commitTime\n            if (a.commitTime > commitTime) {\n                commitTime = a.commitTime;\n            }\n        }\n    }\n\n    /// @notice A getter to find the oldest pledge that hasn't been canceled\n    /// @param idPledge The starting place to lookup the pledges\n    /// @return The oldest idPledge that hasn't been canceled (DUH!)\n    function _getOldestPledgeNotCanceled(\n        uint64 idPledge\n    ) internal view returns(uint64)\n    {\n        if (idPledge == 0) {\n            return 0;\n        }\n\n        Pledge storage p = _findPledge(idPledge);\n        PledgeAdmin storage admin = _findAdmin(p.owner);\n        \n        if (admin.adminType == PledgeAdminType.Giver) {\n            return idPledge;\n        }\n\n        assert(admin.adminType == PledgeAdminType.Project);\n        if (!isProjectCanceled(p.owner)) {\n            return idPledge;\n        }\n\n        return _getOldestPledgeNotCanceled(p.oldPledge);\n    }\n\n    /// @notice `callPlugin` is used to trigger the general functions in the\n    ///  plugin for any actions needed before and after a transfer happens.\n    ///  Specifically what this does in relation to the plugin is something\n    ///  that largely depends on the functions of that plugin. This function\n    ///  is generally called in pairs, once before, and once after a transfer.\n    /// @param before This toggle determines whether the plugin call is occurring\n    ///  before or after a transfer.\n    /// @param adminId This should be the Id of the *trusted* individual\n    ///  who has control over this plugin.\n    /// @param fromPledge This is the Id from which value is being transfered.\n    /// @param toPledge This is the Id that value is being transfered to.\n    /// @param context The situation that is triggering the plugin. See plugin\n    ///  for a full description of contexts.\n    /// @param amount The amount of value that is being transfered.\n    function _callPlugin(\n        bool before,\n        uint64 adminId,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint64 context,\n        address token,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        uint newAmount;\n        allowedAmount = amount;\n        PledgeAdmin storage admin = _findAdmin(adminId);\n\n        // Checks admin has a plugin assigned and a non-zero amount is requested\n        if (address(admin.plugin) != 0 && allowedAmount > 0) {\n            // There are two separate functions called in the plugin.\n            // One is called before the transfer and one after\n            if (before) {\n                newAmount = admin.plugin.beforeTransfer(\n                    adminId,\n                    fromPledge,\n                    toPledge,\n                    context,\n                    token,\n                    amount\n                );\n                require(newAmount <= allowedAmount);\n                allowedAmount = newAmount;\n            } else {\n                admin.plugin.afterTransfer(\n                    adminId,\n                    fromPledge,\n                    toPledge,\n                    context,\n                    token,\n                    amount\n                );\n            }\n        }\n    }\n\n    /// @notice `callPluginsPledge` is used to apply plugin calls to\n    ///  the delegate chain and the intended project if there is one.\n    ///  It does so in either a transferring or receiving context based\n    ///  on the `p` and  `fromPledge` parameters.\n    /// @param before This toggle determines whether the plugin call is occuring\n    ///  before or after a transfer.\n    /// @param idPledge This is the id of the pledge on which this plugin\n    ///  is being called.\n    /// @param fromPledge This is the Id from which value is being transfered.\n    /// @param toPledge This is the Id that value is being transfered to.\n    /// @param amount The amount of value that is being transfered.\n    function _callPluginsPledge(\n        bool before,\n        uint64 idPledge,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        // Determine if callPlugin is being applied in a receiving\n        // or transferring context\n        uint64 offset = idPledge == fromPledge ? 0 : 256;\n        allowedAmount = amount;\n        Pledge storage p = _findPledge(idPledge);\n\n        // Always call the plugin on the owner\n        allowedAmount = _callPlugin(\n            before,\n            p.owner,\n            fromPledge,\n            toPledge,\n            offset,\n            p.token,\n            allowedAmount\n        );\n\n        // Apply call plugin to all delegates\n        for (uint64 i = 0; i < p.delegationChain.length; i++) {\n            allowedAmount = _callPlugin(\n                before,\n                p.delegationChain[i],\n                fromPledge,\n                toPledge,\n                offset + i + 1,\n                p.token,\n                allowedAmount\n            );\n        }\n\n        // If there is an intended project also call the plugin in\n        // either a transferring or receiving context based on offset\n        // on the intended project\n        if (p.intendedProject > 0) {\n            allowedAmount = _callPlugin(\n                before,\n                p.intendedProject,\n                fromPledge,\n                toPledge,\n                offset + 255,\n                p.token,\n                allowedAmount\n            );\n        }\n    }\n\n    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer\n    ///  context and once for the receiving context. The aggregated \n    ///  allowed amount is then returned.\n    /// @param before This toggle determines whether the plugin call is occurring\n    ///  before or after a transfer.\n    /// @param fromPledge This is the Id from which value is being transferred.\n    /// @param toPledge This is the Id that value is being transferred to.\n    /// @param amount The amount of value that is being transferred.\n    function _callPlugins(\n        bool before,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        allowedAmount = amount;\n\n        // Call the plugins in the transfer context\n        allowedAmount = _callPluginsPledge(\n            before,\n            fromPledge,\n            fromPledge,\n            toPledge,\n            allowedAmount\n        );\n\n        // Call the plugins in the receive context\n        allowedAmount = _callPluginsPledge(\n            before,\n            toPledge,\n            fromPledge,\n            toPledge,\n            allowedAmount\n        );\n    }\n\n/////////////\n// Test functions\n/////////////\n\n    /// @notice Basic helper function to return the current time\n    function _getTime() internal view returns (uint) {\n        return now;\n    }\n}\n"
    },
    "./contracts/LiquidPledging.sol": {
      "keccak256": "0xc98ae77346207a5fcdf07aac0f7f1ad366e517070a40ac56b859b8ca5a31ba3d",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LiquidPledging.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n    Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledgingBase.sol\";\n\n/// @dev `LiquidPledging` allows for liquid pledging through the use of\n///  internal id structures and delegate chaining. All basic operations for\n///  handling liquid pledging are supplied as well as plugin features\n///  to allow for expanded functionality.\ncontract LiquidPledging is LiquidPledgingBase {\n\n    function LiquidPledging(address _escapeHatchDestination) EscapableApp(_escapeHatchDestination) public {\n    }\n\n    function addGiverAndDonate(uint64 idReceiver, address token, uint amount)\n        public\n    {\n        addGiverAndDonate(idReceiver, msg.sender, token, amount);\n    }\n\n    function addGiverAndDonate(uint64 idReceiver, address donorAddress, address token, uint amount)\n        public\n    {\n        require(donorAddress != 0);\n        // default to a 3 day (259200 seconds) commitTime\n        uint64 idGiver = addGiver(donorAddress, \"\", \"\", 259200, ILiquidPledgingPlugin(0));\n        donate(idGiver, idReceiver, token, amount);\n    }\n\n    /// @notice This is how value enters the system and how pledges are created;\n    ///  the ether is sent to the vault, an pledge for the Giver is created (or\n    ///  found), the amount of ETH donated in wei is added to the `amount` in\n    ///  the Giver's Pledge, and an LP transfer is done to the idReceiver for\n    ///  the full amount\n    /// @param idGiver The id of the Giver donating\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    function donate(uint64 idGiver, uint64 idReceiver, address token, uint amount)\n        public\n    {\n        require(idGiver > 0); // prevent burning donations. idReceiver is checked in _transfer\n        require(amount > 0);\n        require(token != 0x0);\n\n        PledgeAdmin storage sender = _findAdmin(idGiver);\n        require(sender.adminType == PledgeAdminType.Giver);\n\n        // TODO should this be done at the end of this function?\n        // what re-entrancy issues are there if this is done here?\n        // if done at the end of the function, will that affect plugins?\n        require(ERC20(token).transferFrom(msg.sender, address(vault), amount)); // transfer the token to the `vault`\n\n        uint64 idPledge = _findOrCreatePledge(\n            idGiver,\n            new uint64[](0), // Creates empty array for delegationChain\n            0,\n            0,\n            0,\n            token,\n            PledgeState.Pledged\n        );\n\n        Pledge storage pTo = _findPledge(idPledge);\n        pTo.amount += amount;\n\n        Transfer(0, idPledge, amount);\n\n        _transfer(idGiver, idPledge, amount, idReceiver);\n    }\n\n    /// @notice Transfers amounts between pledges for internal accounting\n    /// @param idSender Id of the Admin that is transferring the amount from\n    ///  Pledge to Pledge; this admin must have permissions to move the value\n    /// @param idPledge Id of the pledge that's moving the value\n    /// @param amount Quantity of ETH (in wei) that this pledge is transferring \n    ///  the authority to withdraw from the vault\n    /// @param idReceiver Destination of the `amount`, can be a Giver/Project sending\n    ///  to a Giver, a Delegate or a Project; a Delegate sending to another\n    ///  Delegate, or a Delegate pre-commiting it to a Project \n    function transfer( \n        uint64 idSender,\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) public\n    {\n        _checkAdminOwner(idSender);\n        _transfer(idSender, idPledge, amount, idReceiver);\n    }\n\n    /// @notice Authorizes a payment be made from the `vault` can be used by the\n    ///  Giver to veto a pre-committed donation from a Delegate to an\n    ///  intendedProject\n    /// @param idPledge Id of the pledge that is to be redeemed into ether\n    /// @param amount Quantity of ether (in wei) to be authorized\n    function withdraw(uint64 idPledge, uint amount) public {\n        idPledge = normalizePledge(idPledge); // Updates pledge info \n\n        Pledge storage p = _findPledge(idPledge);\n        require(p.pledgeState == PledgeState.Pledged);\n        _checkAdminOwner(p.owner);\n\n        uint64 idNewPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Paying\n        );\n\n        _doTransfer(idPledge, idNewPledge, amount);\n\n        PledgeAdmin storage owner = _findAdmin(p.owner);\n        vault.authorizePayment(bytes32(idNewPledge), owner.addr, p.token, amount);\n    }\n\n    /// @notice `onlyVault` Confirms a withdraw request changing the PledgeState\n    ///  from Paying to Paid\n    /// @param idPledge Id of the pledge that is to be withdrawn\n    /// @param amount Quantity of ether (in wei) to be withdrawn\n    function confirmPayment(uint64 idPledge, uint amount) public onlyVault {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.pledgeState == PledgeState.Paying);\n\n        uint64 idNewPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Paid\n        );\n\n        _doTransfer(idPledge, idNewPledge, amount);\n    }\n\n    /// @notice `onlyVault` Cancels a withdraw request, changing the PledgeState\n    ///  from Paying back to Pledged\n    /// @param idPledge Id of the pledge that's withdraw is to be canceled\n    /// @param amount Quantity of ether (in wei) to be canceled\n    function cancelPayment(uint64 idPledge, uint amount) public onlyVault {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.pledgeState == PledgeState.Paying);\n\n        // When a payment is canceled, never is assigned to a project.\n        uint64 idOldPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n\n        idOldPledge = normalizePledge(idOldPledge);\n\n        _doTransfer(idPledge, idOldPledge, amount);\n    }\n\n    /// @notice Changes the `project.canceled` flag to `true`; cannot be undone\n    /// @param idProject Id of the project that is to be canceled\n    function cancelProject(uint64 idProject) public {\n        PledgeAdmin storage project = _findAdmin(idProject);\n        _checkAdminOwner(idProject);\n        project.canceled = true;\n\n        CancelProject(idProject);\n    }\n\n    /// @notice Transfers `amount` in `idPledge` back to the `oldPledge` that\n    ///  that sent it there in the first place, a Ctrl-z \n    /// @param idPledge Id of the pledge that is to be canceled\n    /// @param amount Quantity of ether (in wei) to be transfered to the \n    ///  `oldPledge`\n    function cancelPledge(uint64 idPledge, uint amount) public {\n        idPledge = normalizePledge(idPledge);\n\n        Pledge storage p = _findPledge(idPledge);\n        require(p.oldPledge != 0);\n        require(p.pledgeState == PledgeState.Pledged);\n        _checkAdminOwner(p.owner);\n\n        uint64 oldPledge = _getOldestPledgeNotCanceled(p.oldPledge);\n        _doTransfer(idPledge, oldPledge, amount);\n    }\n\n\n////////\n// Multi pledge methods\n////////\n\n    // @dev This set of functions makes moving a lot of pledges around much more\n    // efficient (saves gas) than calling these functions in series\n    \n    \n    /// @dev Bitmask used for dividing pledge amounts in Multi pledge methods\n    uint constant D64 = 0x10000000000000000;\n\n    /// @notice Transfers multiple amounts within multiple Pledges in an\n    ///  efficient single call \n    /// @param idSender Id of the Admin that is transferring the amounts from\n    ///  all the Pledges; this admin must have permissions to move the value\n    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with \n    ///  which the amounts are associated; these are extrapolated using the D64\n    ///  bitmask\n    /// @param idReceiver Destination of the `pledesAmounts`, can be a Giver or \n    ///  Project sending to a Giver, a Delegate or a Project; a Delegate sending\n    ///  to another Delegate, or a Delegate pre-commiting it to a Project \n    function mTransfer(\n        uint64 idSender,\n        uint[] pledgesAmounts,\n        uint64 idReceiver\n    ) public \n    {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            transfer(idSender, idPledge, amount, idReceiver);\n        }\n    }\n\n    /// @notice Authorizes multiple amounts within multiple Pledges to be\n    ///  withdrawn from the `vault` in an efficient single call \n    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with \n    ///  which the amounts are associated; these are extrapolated using the D64\n    ///  bitmask\n    function mWithdraw(uint[] pledgesAmounts) public {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            withdraw(idPledge, amount);\n        }\n    }\n\n    /// @notice `mConfirmPayment` allows for multiple pledges to be confirmed\n    ///  efficiently\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\n    ///  using the D64 bitmask\n    function mConfirmPayment(uint[] pledgesAmounts) public {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            confirmPayment(idPledge, amount);\n        }\n    }\n\n    /// @notice `mCancelPayment` allows for multiple pledges to be canceled\n    ///  efficiently\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\n    ///  using the D64 bitmask\n    function mCancelPayment(uint[] pledgesAmounts) public {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            cancelPayment(idPledge, amount);\n        }\n    }\n\n    /// @notice `mNormalizePledge` allows for multiple pledges to be\n    ///  normalized efficiently\n    /// @param pledges An array of pledge IDs\n    function mNormalizePledge(uint64[] pledges) public {\n        for (uint i = 0; i < pledges.length; i++ ) {\n            normalizePledge(pledges[i]);\n        }\n    }\n}\n"
    },
    "./contracts/LPConstants.sol": {
      "keccak256": "0x558e8800a807b65c952c7d731ca1c5c42539d734df4d545f801ecff0f0cd2314",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LPConstants.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"@aragon/os/contracts/kernel/KernelStorage.sol\";\n\ncontract LPConstants is KernelConstants {\n    bytes32 constant public VAULT_APP_ID = keccak256(\"vault\");\n    bytes32 constant public LP_APP_ID = keccak256(\"liquidPledging\");\n}"
    },
    "./contracts/LiquidPledgingMock.sol": {
      "keccak256": "0x3191a93f6884af60938a75a327196b1e5192b448b1e6ea26e92988042a132273",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/LiquidPledgingMock.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n/*\n    Copyright 2017, Jordi Baylina\n    Contributor: Adri√† Massanet <adria@codecontext.io>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledging.sol\";\n\n/// @dev `LiquidPledgingMock` allows for mocking up\n///  a `LiquidPledging` contract with the added ability\n///  to manipulate the block time for testing purposes.\ncontract LiquidPledgingMock is LiquidPledging {\n\n    uint public mock_time;\n\n    function LiquidPledgingMock(address _escapeHatchDestination) LiquidPledging(_escapeHatchDestination) public {\n    }\n\n    /// @dev `LiquidPledgingMock` creates a standard `LiquidPledging`\n    ///  instance and sets the mocked time to the current blocktime.\n    function initialize(address _vault, address _escapeHatchDestination) onlyInit public {\n        super.initialize(_vault, _escapeHatchDestination);\n        mock_time = now;\n    }\n\n    /// @dev `getTime` is a basic getter function for\n    ///  the mock_time parameter\n    function _getTime() internal view returns (uint) {\n        return mock_time;\n    }\n\n    /// @dev `setMockedTime` is a basic setter function for\n    ///  the mock_time parameter\n    /// @param _t This is the value to which the mocked time\n    ///  will be set.\n    function setMockedTime(uint _t) public {\n        mock_time = _t;\n    }\n}\n"
    },
    "./contracts/test/TestSimpleDelegatePlugin.sol": {
      "keccak256": "0xbf3f85c43cc59d922946a49ba872a8b634210f2d2169111001429e31dab2638a",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/test/TestSimpleDelegatePlugin.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\nimport \"../LiquidPledging.sol\";\n\n// simple liquidPledging plugin contract for testing whitelist\ncontract TestSimpleDelegatePlugin {\n\n    uint64 public idDelegate;\n    LiquidPledging liquidPledging;\n    bool initPending;\n\n    event BeforeTransfer(uint64 pledgeAdmin, uint64 pledgeFrom, uint64 pledgeTo, uint64 context, uint amount);\n    event AfterTransfer(uint64 pledgeAdmin, uint64 pledgeFrom, uint64 pledgeTo, uint64 context, uint amount);\n\n    function TestSimpleDelegatePlugin(LiquidPledging _liquidPledging) public {\n        require(msg.sender != tx.origin); // Avoids being created directly by mistake.\n        liquidPledging = _liquidPledging;\n        initPending = true;\n    }\n\n    function init(\n        string name,\n        string url,\n        uint64 commitTime\n    ) public {\n        require(initPending);\n        idDelegate = liquidPledging.addDelegate(name, url, commitTime, ILiquidPledgingPlugin(this));\n        initPending = false;\n    }\n\n    function beforeTransfer(\n        uint64 pledgeAdmin,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        uint amount\n    ) external returns (uint maxAllowed) {\n        require(!initPending);\n        BeforeTransfer(pledgeAdmin, pledgeFrom, pledgeTo, context, amount);\n    }\n\n    function afterTransfer(\n        uint64 pledgeAdmin,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        uint amount\n    ) external {\n        require(!initPending);\n        AfterTransfer(pledgeAdmin, pledgeFrom, pledgeTo, context, amount);\n    }\n\n}\n\ncontract TestSimpleDelegatePluginFactory {\n\n    function TestSimpleDelegatePluginFactory(\n        LiquidPledging liquidPledging,\n        string name,\n        string url,\n        uint64 commitTime\n    ) public {\n        TestSimpleDelegatePlugin d = new TestSimpleDelegatePlugin(liquidPledging);\n        d.init(name, url, commitTime);\n    }\n\n}\n"
    },
    "./contracts/test/TestSimpleProjectPlugin.sol": {
      "keccak256": "0x85bd601cdc843e7e95cff6478ef9557424b6768148ddaa4c4c1aada19739b159",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/test/TestSimpleProjectPlugin.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\nimport \"../LiquidPledging.sol\";\n\n// simple liquidPledging plugin contract for testing whitelist\ncontract TestSimpleProjectPlugin {\n\n    uint64 public idProject;\n    bool initPending;\n\n    event BeforeTransfer(uint64 pledgeAdmin, uint64 pledgeFrom, uint64 pledgeTo, uint64 context, uint amount);\n    event AfterTransfer(uint64 pledgeAdmin, uint64 pledgeFrom, uint64 pledgeTo, uint64 context, uint amount);\n\n    function TestSimpleProjectPlugin() {\n        require(msg.sender != tx.origin); // Avoids being created directly by mistake.\n        initPending = true;\n    }\n\n    function init(\n        LiquidPledging liquidPledging,\n        string name,\n        string url,\n        uint64 parentProject\n    ) {\n        require(initPending);\n        idProject = liquidPledging.addProject(name, url, address(this), parentProject, 0, ILiquidPledgingPlugin(this));\n        initPending = false;\n    }\n\n    function beforeTransfer(\n        uint64 pledgeAdmin,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        uint amount\n    ) external returns (uint maxAllowed) {\n        require(!initPending);\n        BeforeTransfer(pledgeAdmin, pledgeFrom, pledgeTo, context, amount);\n    }\n\n    function afterTransfer(\n        uint64 pledgeAdmin,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        uint amount\n    ) external {\n        require(!initPending);\n        AfterTransfer(pledgeAdmin, pledgeFrom, pledgeTo, context, amount);\n    }\n\n}\n"
    },
    "./contracts/test/TestSimpleProjectPluginFactory.sol": {
      "keccak256": "0xbcc89d661b95cba0601d86d2472adeebcfd45c8f69a45cc2ec91bba2605a7b08",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/test/TestSimpleProjectPluginFactory.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\nimport \"./TestSimpleProjectPlugin.sol\";\nimport \"../LiquidPledging.sol\";\n\n// simple factory for deploying TestSimpleProjectPlugin.sol contract\ncontract TestSimpleProjectPluginFactory {\n\n    function deploy(\n        LiquidPledging liquidPledging,\n        string name,\n        string url,\n        uint64 parentProject\n    ) {\n        TestSimpleProjectPlugin p = new TestSimpleProjectPlugin();\n        p.init(liquidPledging, name, url, parentProject);\n    }\n\n}\n"
    },
    "./contracts/test/StandardToken.sol": {
      "keccak256": "0x9a4ae5b291b2fdb616bf902bff927d7b1bd0c1f3bcd6f0745f8e0c13dbb0ae55",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/contracts/test/StandardToken.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/**\n * WARNING: This token is for testing purposes only \n * and has been modified from the original version: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol\n * \n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken {\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n  address owner;\n\n  function StandardToken() public {\n      owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n      require(msg.sender == owner);\n      _;\n  }\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  function mint(address _to, uint _value) public onlyOwner {\n      totalSupply_ += _value;\n      balances[_to] += _value;\n      Transfer(0, _to, _value); \n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender] - _value;\n    balances[_to] = balances[_to] + _value;\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from] - _value;\n    balances[_to] = balances[_to] + _value;\n    allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue - _subtractedValue;\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}"
    },
    "./node_modules/@aragon/os/contracts/kernel/Kernel.sol": {
      "keccak256": "0x0525a68271476d181b698069adf27074e3d5f058a331b71424479489df30694d",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/kernel/Kernel.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./IKernel.sol\";\nimport \"./KernelStorage.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../apps/IAppProxy.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../factory/AppProxyFactory.sol\";\n\n\ncontract Kernel is IKernel, KernelStorage, Initializable, AppProxyFactory, ACLSyntaxSugar {\n    bytes32 constant public APP_MANAGER_ROLE = bytes32(1);\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes a kernel instance along with its ACL and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _baseAcl Address of base ACL app\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _baseAcl, address _permissionsCreator) onlyInit public {\n        initialized();\n\n        IACL acl = IACL(newAppProxy(this, ACL_APP_ID));\n\n        _setApp(APP_BASES_NAMESPACE, ACL_APP_ID, _baseAcl);\n        _setApp(APP_ADDR_NAMESPACE, ACL_APP_ID, acl);\n\n        acl.initialize(_permissionsCreator);\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel and set its base\n    *      implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (IAppProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxy(this, _name);\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel and set\n    *      its base implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (IAppProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxyPinned(this, _name);\n    }\n\n    /**\n    * @dev Set the resolving address of an app instance or base implementation\n    * @param _namespace App namespace to use\n    * @param _name Name of the app\n    * @param _app Address of the app\n    * @return ID of app\n    */\n    function setApp(bytes32 _namespace, bytes32 _name, address _app) auth(APP_MANAGER_ROLE, arr(_namespace, _name)) kernelIntegrity public returns (bytes32 id) {\n        return _setApp(_namespace, _name, _app);\n    }\n\n    /**\n    * @dev Get the address of an app instance or base implementation\n    * @param _id App identifier\n    * @return Address of the app\n    */\n    function getApp(bytes32 _id) public view returns (address) {\n        return apps[_id];\n    }\n\n    /**\n    * @dev Get the installed ACL app\n    * @return ACL app\n    */\n    function acl() public view returns (IACL) {\n        return IACL(getApp(ACL_APP));\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission status\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _what Identifier for a group of actions in app\n    * @param _how Extra data for ACL auth\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\n        return acl().hasPermission(_who, _where, _what, _how);\n    }\n\n    function _setApp(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        id = keccak256(_namespace, _name);\n        apps[id] = _app;\n        SetApp(_namespace, _name, id, _app);\n    }\n\n    function _setAppIfNew(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        id = keccak256(_namespace, _name);\n\n        if (_app != address(0)) {\n            address app = getApp(id);\n            if (app != address(0)) {\n                require(app == _app);\n            } else {\n                apps[id] = _app;\n                SetApp(_namespace, _name, id, _app);\n            }\n        }\n    }\n\n    modifier auth(bytes32 _role, uint256[] memory params) {\n        bytes memory how;\n        uint256 byteLength = params.length * 32;\n        assembly {\n            how := params // forced casting\n            mstore(how, byteLength)\n        }\n        // Params is invalid from this point fwd\n        require(hasPermission(msg.sender, address(this), _role, how));\n        _;\n    }\n\n    modifier kernelIntegrity {\n        _; // After execution check integrity\n        address kernel = getApp(KERNEL_APP);\n        uint256 size;\n        assembly { size := extcodesize(kernel) }\n        require(size > 0);\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/acl/IACL.sol": {
      "keccak256": "0xa120fc32d8d2c5096d605b0fe012d5b1e4a62118952a25a18bac5210f4fceede",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IACL {\n    function initialize(address permissionsCreator) public;\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/kernel/IKernel.sol": {
      "keccak256": "0xc4bd88d7355351f68614906f04d7a67b4fcd81b28112f75df090b7eb8b93c881",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../acl/IACL.sol\";\n\ninterface IKernel {\n    event SetApp(bytes32 indexed namespace, bytes32 indexed name, bytes32 indexed id, address app);\n\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 name, address app) public returns (bytes32 id);\n    function getApp(bytes32 id) public view returns (address);\n}"
    },
    "./node_modules/@aragon/os/contracts/kernel/KernelStorage.sol": {
      "keccak256": "0x5eeaeb6e75a435278d5a2d74dab865bd9c2a88fba296db5b8669769d6a60573e",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract KernelConstants {\n    bytes32 constant public CORE_NAMESPACE = keccak256(\"core\");\n    bytes32 constant public APP_BASES_NAMESPACE = keccak256(\"base\");\n    bytes32 constant public APP_ADDR_NAMESPACE = keccak256(\"app\");\n\n    bytes32 constant public KERNEL_APP_ID = keccak256(\"kernel.aragonpm.eth\");\n    bytes32 constant public KERNEL_APP = keccak256(CORE_NAMESPACE, KERNEL_APP_ID);\n\n    bytes32 constant public ACL_APP_ID = keccak256(\"acl.aragonpm.eth\");\n    bytes32 constant public ACL_APP = keccak256(APP_ADDR_NAMESPACE, ACL_APP_ID);\n}\n\n\ncontract KernelStorage is KernelConstants {\n    mapping (bytes32 => address) public apps;\n}\n"
    },
    "./node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol": {
      "keccak256": "0x92c85fe20e03c5fde11c3006b2acd7c24021d53356bd14070522d71912e5419b",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract ACLSyntaxSugar {\n    function arr() internal pure returns (uint256[] r) {}\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}\n\n\ncontract ACLHelpers {\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/IAppProxy.sol": {
      "keccak256": "0x4d5f398f887030d6d0b5045e0424b59d58abd718143289afcaf3e160d6c91736",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\ninterface IAppProxy {\n    function isUpgradeable() public pure returns (bool);\n    function getCode() public view returns (address);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/AppStorage.sol": {
      "keccak256": "0x8b9205a3fdf9d94fb1461d2c2d32335803122aa75d3fa8cf0b982796fd040c25",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppStorage {\n    IKernel public kernel;\n    bytes32 public appId;\n    address internal pinnedCode; // used by Proxy Pinned\n    uint256 internal initializationBlock; // used by Initializable\n    uint256[95] private storageOffset; // forces App storage to start at after 100 slots\n    uint256 private offset;\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/Initializable.sol": {
      "keccak256": "0x07ef04e0cf56217c5e103a760dd577a7fffa06ca166dc15af35b3895e58880e9",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../apps/AppStorage.sol\";\n\n\ncontract Initializable is AppStorage {\n    modifier onlyInit {\n        require(initializationBlock == 0);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        initializationBlock = getBlockNumber();\n    }\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/DelegateProxy.sol": {
      "keccak256": "0x81bab220700a9a5def3ac54278ccec046be0b1c333dba9567f7175e358414d87",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract DelegateProxy {\n    /**\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n    * @param _dst Destination address to perform the delegatecall\n    * @param _calldata Calldata for the delegatecall\n    */\n    function delegatedFwd(address _dst, bytes _calldata) internal {\n        require(isContract(_dst));\n        assembly {\n            let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            let size := returndatasize\n\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n\n    function isContract(address _target) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/AppProxyBase.sol": {
      "keccak256": "0x907218cac02c5f7a10873eb30fb1ffaecdd93527a0ff7e2f0305590bf585d06b",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./IAppProxy.sol\";\nimport \"./AppStorage.sol\";\nimport \"../common/DelegateProxy.sol\";\nimport \"../kernel/KernelStorage.sol\";\n\n\ncontract AppProxyBase is IAppProxy, AppStorage, DelegateProxy, KernelConstants {\n    /**\n    * @dev Initialize AppProxy\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyBase(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n        kernel = _kernel;\n        appId = _appId;\n\n        // Implicit check that kernel is actually a Kernel\n        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\n        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n        // it.\n        address appCode = getAppBase(appId);\n\n        // If initialize payload is provided, it will be executed\n        if (_initializePayload.length > 0) {\n            require(isContract(appCode));\n            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n            // returns ending execution context and halts contract deployment\n            require(appCode.delegatecall(_initializePayload));\n        }\n    }\n\n    function getAppBase(bytes32 _appId) internal view returns (address) {\n        return kernel.getApp(keccak256(APP_BASES_NAMESPACE, _appId));\n    }\n\n    function () payable public {\n        address target = getCode();\n        require(target != 0); // if app code hasn't been set yet, don't call\n        delegatedFwd(target, msg.data);\n    }\n}"
    },
    "./node_modules/@aragon/os/contracts/apps/AppProxyUpgradeable.sol": {
      "keccak256": "0x4613af6e313048b7de649d54630276fb18154dac5674f057109f0e0591f11cb2",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyUpgradeable is AppProxyBase {\n    address public pinnedCode;\n\n    /**\n    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyUpgradeable(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n\n    }\n\n    function getCode() public view returns (address) {\n        return getAppBase(appId);\n    }\n\n    function isUpgradeable() public pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/AppProxyPinned.sol": {
      "keccak256": "0xfe66e88413adc4d60ae53352046bd23ebd0aeb3120599d445df19caa8b095c26",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyPinned is AppProxyBase {\n    /**\n    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n        pinnedCode = getAppBase(appId);\n        require(pinnedCode != address(0));\n    }\n\n    function getCode() public view returns (address) {\n        return pinnedCode;\n    }\n\n    function isUpgradeable() public pure returns (bool) {\n        return false;\n    }\n\n    function () payable public {\n        delegatedFwd(getCode(), msg.data);\n    }\n}"
    },
    "./node_modules/@aragon/os/contracts/factory/AppProxyFactory.sol": {
      "keccak256": "0xa5314f57f93d8e633724bd9f94ad43f127c5b5466dcd0ef32fe0f78d5d431592",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AppProxyUpgradeable.sol\";\nimport \"../apps/AppProxyPinned.sol\";\n\n\ncontract AppProxyFactory {\n    event NewAppProxy(address proxy);\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n        return newAppProxy(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy));\n        return proxy;\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy));\n        return proxy;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/acl/ACL.sol": {
      "keccak256": "0x7e636d70192cc2b18d00df37ff91e1f3b4e5a6dfb0c92f9d90441dceac1f2a25",
      "urls": [
        "file:///Users/rjewing/code/giveth/liquidpledging/node_modules/@aragon/os/contracts/acl/ACL.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AragonApp.sol\";\nimport \"./ACLSyntaxSugar.sol\";\nimport \"./IACL.sol\";\n\n\ninterface ACLOracle {\n    function canPerform(address who, address where, bytes32 what) public view returns (bool);\n}\n\n\ncontract ACL is IACL, AragonApp, ACLHelpers {\n    bytes32 constant public CREATE_PERMISSIONS_ROLE = bytes32(1);\n\n    // whether a certain entity has a permission\n    mapping (bytes32 => bytes32) permissions; // 0 for no permission, or parameters id\n    mapping (bytes32 => Param[]) public permissionParams;\n\n    // who is the manager of a permission\n    mapping (bytes32 => address) permissionManager;\n\n    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, NOT, AND, OR, XOR, IF_ELSE, RET } // op types\n\n    struct Param {\n        uint8 id;\n        uint8 op;\n        uint240 value; // even though value is an uint240 it can store addresses\n        // in the case of 32 byte hashes losing 2 bytes precision isn't a huge deal\n        // op and id take less than 1 byte each so it can be kept in 1 sstore\n    }\n\n    uint8 constant BLOCK_NUMBER_PARAM_ID = 200;\n    uint8 constant TIMESTAMP_PARAM_ID    = 201;\n    uint8 constant SENDER_PARAM_ID       = 202;\n    uint8 constant ORACLE_PARAM_ID       = 203;\n    uint8 constant LOGIC_OP_PARAM_ID     = 204;\n    uint8 constant PARAM_VALUE_PARAM_ID  = 205;\n    // TODO: Add execution times param type?\n\n    bytes32 constant public EMPTY_PARAM_HASH = keccak256(uint256(0));\n    address constant ANY_ENTITY = address(-1);\n\n    modifier onlyPermissionManager(address _app, bytes32 _role) {\n        require(msg.sender == getPermissionManager(_app, _role));\n        _;\n    }\n\n    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\n    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes an ACL instance and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _permissionsCreator) onlyInit public {\n        initialized();\n        require(msg.sender == address(kernel));\n\n        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\n    }\n\n    /**\n    * @dev Creates a permission that wasn't previously set. Access is limited by the ACL.\n    *      If a created permission is removed it is possible to reset it with createPermission.\n    * @notice Create a new permission granting `_entity` the ability to perform actions of role `_role` on `_app` (setting `_manager` as the permission manager)\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\n    */\n    function createPermission(address _entity, address _app, bytes32 _role, address _manager) external {\n        require(hasPermission(msg.sender, address(this), CREATE_PERMISSIONS_ROLE));\n\n        _createPermission(_entity, _app, _role, _manager);\n    }\n\n    /**\n    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    */\n    function grantPermission(address _entity, address _app, bytes32 _role)\n        external\n    {\n        grantPermissionP(_entity, _app, _role, new uint256[](0));\n    }\n\n    /**\n    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _params Permission parameters\n    */\n    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\n        onlyPermissionManager(_app, _role)\n        public\n    {\n        require(!hasPermission(_entity, _app, _role));\n\n        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\n        _setPermission(_entity, _app, _role, paramsHash);\n    }\n\n    /**\n    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\n    * @notice Revokes `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity to revoke access from\n    * @param _app Address of the app in which the role will be revoked\n    * @param _role Identifier for the group of actions in app being revoked\n    */\n    function revokePermission(address _entity, address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        require(hasPermission(_entity, _app, _role));\n\n        _setPermission(_entity, _app, _role, bytes32(0));\n    }\n\n    /**\n    * @notice Sets `_newManager` as the manager of the permission `_role` in `_app`\n    * @param _newManager Address for the new manager\n    * @param _app Address of the app in which the permission management is being transferred\n    * @param _role Identifier for the group of actions being transferred\n    */\n    function setPermissionManager(address _newManager, address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        _setPermissionManager(_newManager, _app, _role);\n    }\n\n    /**\n    * @dev Get manager for permission\n    * @param _app Address of the app\n    * @param _role Identifier for a group of actions in app\n    * @return address of the manager for the permission\n    */\n    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\n        return permissionManager[roleHash(_app, _role)];\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission statu\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _where Identifier for a group of actions in app\n    * @param _how Permission parameters\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\n        uint256[] memory how;\n        uint256 intsLength = _how.length / 32;\n        assembly {\n            how := _how // forced casting\n            mstore(how, intsLength)\n        }\n        // _how is invalid from this point fwd\n        return hasPermission(_who, _where, _what, how);\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\n        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\n        if (whoParams != bytes32(0) && evalParams(whoParams, _who, _where, _what, _how)) {\n            return true;\n        }\n\n        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\n        if (anyParams != bytes32(0) && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\n        uint256[] memory empty = new uint256[](0);\n        return hasPermission(_who, _where, _what, empty);\n    }\n\n    /**\n    * @dev Internal createPermission for access inside the kernel (on instantiation)\n    */\n    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\n        // only allow permission creation (or re-creation) when there is no manager\n        require(getPermissionManager(_app, _role) == address(0));\n\n        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\n        _setPermissionManager(_manager, _app, _role);\n    }\n\n    /**\n    * @dev Internal function called to actually save the permission\n    */\n    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\n        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\n\n        SetPermission(_entity, _app, _role, _paramsHash != bytes32(0));\n    }\n\n    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\n        bytes32 paramHash = keccak256(_encodedParams);\n        Param[] storage params = permissionParams[paramHash];\n\n        if (params.length == 0) { // params not saved before\n            for (uint256 i = 0; i < _encodedParams.length; i++) {\n                uint256 encodedParam = _encodedParams[i];\n                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\n                params.push(param);\n            }\n        }\n\n        return paramHash;\n    }\n\n    function evalParams(\n        bytes32 _paramsHash,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) internal view returns (bool)\n    {\n        if (_paramsHash == EMPTY_PARAM_HASH) {\n            return true;\n        }\n\n        return evalParam(_paramsHash, 0, _who, _where, _what, _how);\n    }\n\n    function evalParam(\n        bytes32 _paramsHash,\n        uint32 _paramId,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) internal view returns (bool)\n    {\n        if (_paramId >= permissionParams[_paramsHash].length) {\n            return false; // out of bounds\n        }\n\n        Param memory param = permissionParams[_paramsHash][_paramId];\n\n        if (param.id == LOGIC_OP_PARAM_ID) {\n            return evalLogic(param, _paramsHash, _who, _where, _what, _how);\n        }\n\n        uint256 value;\n        uint256 comparedTo = uint256(param.value);\n\n        // get value\n        if (param.id == ORACLE_PARAM_ID) {\n            value = ACLOracle(param.value).canPerform(_who, _where, _what) ? 1 : 0;\n            comparedTo = 1;\n        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\n            value = blockN();\n        } else if (param.id == TIMESTAMP_PARAM_ID) {\n            value = time();\n        } else if (param.id == SENDER_PARAM_ID) {\n            value = uint256(msg.sender);\n        } else if (param.id == PARAM_VALUE_PARAM_ID) {\n            value = uint256(param.value);\n        } else {\n            if (param.id >= _how.length) {\n                return false;\n            }\n            value = uint256(uint240(_how[param.id])); // force lost precision\n        }\n\n        if (Op(param.op) == Op.RET) {\n            return uint256(value) > 0;\n        }\n\n        return compare(value, Op(param.op), comparedTo);\n    }\n\n    function evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n        if (Op(_param.op) == Op.IF_ELSE) {\n            var (condition, success, failure) = decodeParamsList(uint256(_param.value));\n            bool result = evalParam(_paramsHash, condition, _who, _where, _what, _how);\n\n            return evalParam(_paramsHash, result ? success : failure, _who, _where, _what, _how);\n        }\n\n        var (v1, v2,) = decodeParamsList(uint256(_param.value));\n        bool r1 = evalParam(_paramsHash, v1, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.NOT) {\n            return !r1;\n        }\n\n        if (r1 && Op(_param.op) == Op.OR) {\n            return true;\n        }\n\n        if (!r1 && Op(_param.op) == Op.AND) {\n            return false;\n        }\n\n        bool r2 = evalParam(_paramsHash, v2, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.XOR) {\n            return (r1 && !r2) || (!r1 && r2);\n        }\n\n        return r2; // both or and and depend on result of r2 after checks\n    }\n\n    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\n        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\n        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\n        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\n        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\n        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\n        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\n        return false;\n    }\n\n    /**\n    * @dev Internal function that sets management\n    */\n    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\n        permissionManager[roleHash(_app, _role)] = _newManager;\n        ChangePermissionManager(_app, _role, _newManager);\n    }\n\n    function roleHash(address _where, bytes32 _what) pure internal returns (bytes32) {\n        return keccak256(uint256(1), _where, _what);\n    }\n\n    function permissionHash(address _who, address _where, bytes32 _what) pure internal returns (bytes32) {\n        return keccak256(uint256(2), _who, _where, _what);\n    }\n\n    function time() internal view returns (uint64) { return uint64(block.timestamp); } // solium-disable-line security/no-block-members\n\n    function blockN() internal view returns (uint256) { return block.number; }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol": {
      "keccak256": "0x6a4beed810085f11cda9d50c3547ac4cc2100d9dc18ab4982ff11dd483410012",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IEVMScriptExecutor {\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol": {
      "keccak256": "0xa0cf92b96ee915266c74d42f3479ee809754264cc783fe9635f74d3795c7b2e1",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract EVMScriptRegistryConstants {\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = keccak256(\"evmreg.aragonpm.eth\");\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP = keccak256(keccak256(\"app\"), EVMSCRIPT_REGISTRY_APP_ID);\n}\n\n\ninterface IEVMScriptRegistry {\n    function addScriptExecutor(address executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    function getScriptExecutor(bytes script) public view returns (address);\n}"
    },
    "./node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol": {
      "keccak256": "0x21a99d2fc9de2244829954ea1c21057f25f74a23f18ac7f7402420922e287517",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity 0.4.18;\n\n\nlibrary ScriptHelpers {\n    // To test with JS and compare with actual encoder. Maintaining for reference.\n    // t = function() { return IEVMScriptExecutor.at('0x4bcdd59d6c77774ee7317fc1095f69ec84421e49').contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\n    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\n    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\n\n    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\n        return encode(_a, _b, _c);\n    }\n\n    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\n        // A is positioned after the 3 position words\n        uint256 aPosition = 0x60;\n        uint256 bPosition = aPosition + 32 * abiLength(_a);\n        uint256 cPosition = bPosition + 32 * abiLength(_b);\n        uint256 length = cPosition + 32 * abiLength(_c);\n\n        d = new bytes(length);\n        assembly {\n            // Store positions\n            mstore(add(d, 0x20), aPosition)\n            mstore(add(d, 0x40), bPosition)\n            mstore(add(d, 0x60), cPosition)\n        }\n\n        // Copy memory to correct position\n        copy(d, getPtr(_a), aPosition, _a.length);\n        copy(d, getPtr(_b), bPosition, _b.length);\n        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\n    }\n\n    function abiLength(bytes memory _a) internal pure returns (uint256) {\n        // 1 for length +\n        // memory words + 1 if not divisible for 32 to offset word\n        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\n    }\n\n    function abiLength(address[] _a) internal pure returns (uint256) {\n        // 1 for length + 1 per item\n        return 1 + _a.length;\n    }\n\n    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\n        uint dest;\n        assembly {\n            dest := add(add(_d, 0x20), _pos)\n        }\n        memcpy(dest, _src, _length + 32);\n    }\n\n    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getSpecId(bytes _script) internal pure returns (uint32) {\n        return uint32At(_script, 0);\n    }\n\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := mload(add(_data, add(0x20, _location)))\n        }\n    }\n\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n            0x1000000000000000000000000)\n        }\n    }\n\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n            0x100000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := add(_data, add(0x20, _location))\n        }\n    }\n\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n        bytes memory payload = new bytes(4);\n        payload[0] = bytes1(_sig);\n        payload[1] = bytes1(_sig << 8);\n        payload[2] = bytes1(_sig << 16);\n        payload[3] = bytes1(_sig << 24);\n        return payload;\n    }\n\n    function memcpy(uint _dest, uint _src, uint _len) public pure {\n        uint256 src = _src;\n        uint256 dest = _dest;\n        uint256 len = _len;\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}"
    },
    "./node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol": {
      "keccak256": "0xf226f2c5c0a930340d49a5f79ac49a18dc0f88632acdef32c4eb698d5bb8a77e",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../apps/AppStorage.sol\";\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"./ScriptHelpers.sol\";\n\n\ncontract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {\n    using ScriptHelpers for bytes;\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {\n        // TODO: Too much data flying around, maybe extracting spec id here is cheaper\n        address executorAddr = getExecutor(_script);\n        require(executorAddr != address(0));\n\n        bytes memory calldataArgs = _script.encode(_input, _blacklist);\n        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;\n\n        require(executorAddr.delegatecall(sig, calldataArgs));\n\n        return returnedDataDecoded();\n    }\n\n    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));\n    }\n\n    // TODO: Internal\n    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    /**\n    * @dev copies and returns last's call data. Needs to ABI decode first\n    */\n    function returnedDataDecoded() internal view returns (bytes ret) {\n        assembly {\n            let size := returndatasize\n            switch size\n            case 0 {}\n            default {\n                ret := mload(0x40) // free mem ptr get\n                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data\n            }\n        }\n        return ret;\n    }\n\n    modifier protectState {\n        address preKernel = kernel;\n        bytes32 preAppId = appId;\n        _; // exec\n        require(kernel == preKernel);\n        require(appId == preAppId);\n    }\n}"
    },
    "./node_modules/@aragon/os/contracts/apps/AragonApp.sol": {
      "keccak256": "0x7b5ed0ab203aea14886f337bc8b73ec49177415d43b3251d917d51a6d138d8f1",
      "urls": [
        "file://undefined"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./AppStorage.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../evmscript/EVMScriptRunner.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\n\n\ncontract AragonApp is AppStorage, Initializable, ACLSyntaxSugar, EVMScriptRunner {\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)));\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] params) {\n        require(canPerform(msg.sender, _role, params));\n        _;\n    }\n\n    function canPerform(address _sender, bytes32 _role, uint256[] params) public view returns (bool) {\n        bytes memory how; // no need to init memory as it is never used\n        if (params.length > 0) {\n            uint256 byteLength = params.length * 32;\n            assembly {\n                how := params // forced casting\n                mstore(how, byteLength)\n            }\n        }\n        return address(kernel) == 0 || kernel.hasPermission(_sender, address(this), _role, how);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "abi",
          "evm.methodIdentifiers",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap"
        ]
      }
    }
  }
}