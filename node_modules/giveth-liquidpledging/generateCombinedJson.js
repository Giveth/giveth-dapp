#!/usr/bin/env node
const fs = require('fs');
const path = require('path');


const yargs = require('yargs')
  .usage('Usage: $0 [options]')
  .option('output', {
    alias: 'o',
    describe: 'Solidity standardJson output file to convert',
    type: 'string',
  })
  .option('input', {
    alias: 'i',
    describe: 'Solidity standardJson input file',
    type: 'string',
  })
  .help()
  .argv;

if (!yargs.input) throw new Error('input is a required arg');
if (!yargs.output) throw new Error('output is a required arg');

generateCombinedJson(yargs.input, yargs.output);

function generateCombinedJson(inputFile, outputFile) {
  let combinedJson = {
    contracts: {},
    sourceList: new Set([])
  };

  const standardOutput = JSON.parse(fs.readFileSync(outputFile));
  const standardInput = JSON.parse(fs.readFileSync(inputFile));

  Object.keys(standardOutput.contracts).forEach(f => {
    Object.keys(standardOutput.contracts[f]).forEach(c => {
      const file = standardInput.sources[f].urls[0].slice(7).replace(process.cwd(), '.') // get rid of file:// prefix & make relative
      const cn = `${file}:${c}`;
      const contract = standardOutput.contracts[f][c];

      combinedJson.sourceList.add(file);
      combinedJson.contracts[cn] = {
        abi: JSON.stringify(contract.abi),
        bin: contract.evm.bytecode.object,
        'bin-runtime': contract.evm.deployedBytecode.object,
        srcmap: contract.evm.bytecode.sourceMap,
        'srcmap-runtime': contract.evm.deployedBytecode.sourceMap
      };
    });
  })

  combinedJson.sourceList = Array.from(combinedJson.sourceList);

  fs.writeFileSync(path.join(path.dirname(yargs.output), 'combined.json'), JSON.stringify(combinedJson));
}

